package app

import (
	"fmt"
	"os"
	"runtime"
	"runtime/pprof"
	"testing"
	"time"

	tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
)

// TestBlockLifecycleResourceLeak repeatedly runs the failing input to reproduce resource leaks
func TestBlockLifecycleResourceLeak(t *testing.T) {
	// The failing input from fuzzing
	failingTimestamp := int64(1750678259)

	fmt.Printf("Starting resource leak test with timestamp %d (%s)\n", failingTimestamp, time.Unix(failingTimestamp, 0))

	// Track initial resources
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	initialGoroutines := runtime.NumGoroutine()
	fmt.Printf("Initial - Memory: %d MB, Goroutines: %d\n", m.Alloc/1024/1024, initialGoroutines)

	// Run the test multiple times to see if resources accumulate
	for i := 0; i < 3; i++ { // Reduced to 3 iterations for debugging
		fmt.Printf("\n--- Iteration %d ---\n", i+1)

		// Force GC before each iteration
		runtime.GC()

		// Track resources before iteration
		runtime.ReadMemStats(&m)
		beforeGoroutines := runtime.NumGoroutine()
		fmt.Printf("Before iteration - Memory: %d MB, Goroutines: %d\n", m.Alloc/1024/1024, beforeGoroutines)

		// Run the test
		func() {
			chain := Setup(t)
			ctx := chain.NewContext(false)
			ctx = ctx.WithBlockHeader(tmproto.Header{Time: time.Unix(failingTimestamp, 0)})

			// Cleanup
			defer func() {
				_, _ = chain.Commit()
				runtime.GC()
				if err := chain.Close(); err != nil {
					fmt.Printf("DEBUG: chain.Close() error: %v\n", err)
				}
			}()

			// Run BeginBlocker with timeout
			beginDone := make(chan error, 1)
			go func() {
				if _, err := chain.BeginBlocker(ctx); err != nil {
					beginDone <- err
					return
				}
				beginDone <- nil
			}()

			select {
			case err := <-beginDone:
				if err != nil {
					t.Fatalf("BeginBlocker failed: %v", err)
				}
			case <-time.After(2 * time.Second):
				t.Fatalf("BeginBlocker timed out")
			}

			// Run EndBlocker with timeout
			endDone := make(chan error, 1)
			go func() {
				if _, err := chain.EndBlocker(ctx); err != nil {
					endDone <- err
					return
				}
				endDone <- nil
			}()

			select {
			case err := <-endDone:
				if err != nil {
					t.Fatalf("EndBlocker failed: %v", err)
				}
			case <-time.After(2 * time.Second):
				t.Fatalf("EndBlocker timed out")
			}
		}()

		// Track resources after iteration
		runtime.ReadMemStats(&m)
		afterGoroutines := runtime.NumGoroutine()
		fmt.Printf("After iteration - Memory: %d MB, Goroutines: %d\n", m.Alloc/1024/1024, afterGoroutines)

		// Check for resource leaks
		if afterGoroutines > beforeGoroutines {
			fmt.Printf("WARNING: Goroutine leak detected! +%d goroutines\n", afterGoroutines-beforeGoroutines)

			// Dump goroutine stack traces to see what's leaking
			fmt.Printf("=== GOROUTINE STACK TRACES ===\n")
			if err := pprof.Lookup("goroutine").WriteTo(os.Stdout, 1); err != nil {
				fmt.Printf("Error writing goroutine profile: %v\n", err)
			}
			fmt.Printf("=== END STACK TRACES ===\n")
		}

		// Small delay to allow cleanup
		time.Sleep(100 * time.Millisecond)
	}

	// Final resource check
	runtime.ReadMemStats(&m)
	finalGoroutines := runtime.NumGoroutine()
	fmt.Printf("\nFinal - Memory: %d MB, Goroutines: %d\n", m.Alloc/1024/1024, finalGoroutines)

	// TODO: Uncomment to fail on leaks once stable
	// if finalGoroutines > initialGoroutines {
	// 	t.Errorf("Resource leak detected: +%d goroutines", finalGoroutines-initialGoroutines)
	// }
}
