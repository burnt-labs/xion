//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: cosmos/app/v1alpha1/module.proto

package cosmos.app.v1alpha1;

@kotlin.jvm.JvmName("-initializepackageReference")
public inline fun packageReference(block: cosmos.app.v1alpha1.PackageReferenceKt.Dsl.() -> kotlin.Unit): cosmos.app.v1alpha1.Module.PackageReference =
  cosmos.app.v1alpha1.PackageReferenceKt.Dsl._create(cosmos.app.v1alpha1.Module.PackageReference.newBuilder()).apply { block() }._build()
public object PackageReferenceKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: cosmos.app.v1alpha1.Module.PackageReference.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: cosmos.app.v1alpha1.Module.PackageReference.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): cosmos.app.v1alpha1.Module.PackageReference = _builder.build()

    /**
     * <pre>
     * name is the fully-qualified name of the package.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     */
    public var name: kotlin.String
      @JvmName("getName")
      get() = _builder.getName()
      @JvmName("setName")
      set(value) {
        _builder.setName(value)
      }
    /**
     * <pre>
     * name is the fully-qualified name of the package.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     */
    public fun clearName() {
      _builder.clearName()
    }

    /**
     * <pre>
     * revision is the optional revision of the package that is being used.
     * Protobuf packages used in Cosmos should generally have a major version
     * as the last part of the package name, ex. foo.bar.baz.v1.
     * The revision of a package can be thought of as the minor version of a
     * package which has additional backwards compatible definitions that weren't
     * present in a previous version.
     * A package should indicate its revision with a source code comment
     * above the package declaration in one of its files containing the
     * text "Revision N" where N is an integer revision. All packages start
     * at revision 0 the first time they are released in a module.
     * When a new version of a module is released and items are added to existing
     * .proto files, these definitions should contain comments of the form
     * "Since: Revision N" where N is an integer revision.
     * When the module runtime starts up, it will check the pinned proto
     * image and panic if there are runtime protobuf definitions that are not
     * in the pinned descriptor which do not have
     * a "Since Revision N" comment or have a "Since Revision N" comment where
     * N is &lt;= to the revision specified here. This indicates that the protobuf
     * files have been updated, but the pinned file descriptor hasn't.
     * If there are items in the pinned file descriptor with a revision
     * greater than the value indicated here, this will also cause a panic
     * as it may mean that the pinned descriptor for a legacy module has been
     * improperly updated or that there is some other versioning discrepancy.
     * Runtime protobuf definitions will also be checked for compatibility
     * with pinned file descriptors to make sure there are no incompatible changes.
     * This behavior ensures that:
     * * pinned proto images are up-to-date
     * * protobuf files are carefully annotated with revision comments which
     *   are important good client UX
     * * protobuf files are changed in backwards and forwards compatible ways
     * </pre>
     *
     * <code>uint32 revision = 2 [json_name = "revision"];</code>
     */
    public var revision: kotlin.Int
      @JvmName("getRevision")
      get() = _builder.getRevision()
      @JvmName("setRevision")
      set(value) {
        _builder.setRevision(value)
      }
    /**
     * <pre>
     * revision is the optional revision of the package that is being used.
     * Protobuf packages used in Cosmos should generally have a major version
     * as the last part of the package name, ex. foo.bar.baz.v1.
     * The revision of a package can be thought of as the minor version of a
     * package which has additional backwards compatible definitions that weren't
     * present in a previous version.
     * A package should indicate its revision with a source code comment
     * above the package declaration in one of its files containing the
     * text "Revision N" where N is an integer revision. All packages start
     * at revision 0 the first time they are released in a module.
     * When a new version of a module is released and items are added to existing
     * .proto files, these definitions should contain comments of the form
     * "Since: Revision N" where N is an integer revision.
     * When the module runtime starts up, it will check the pinned proto
     * image and panic if there are runtime protobuf definitions that are not
     * in the pinned descriptor which do not have
     * a "Since Revision N" comment or have a "Since Revision N" comment where
     * N is &lt;= to the revision specified here. This indicates that the protobuf
     * files have been updated, but the pinned file descriptor hasn't.
     * If there are items in the pinned file descriptor with a revision
     * greater than the value indicated here, this will also cause a panic
     * as it may mean that the pinned descriptor for a legacy module has been
     * improperly updated or that there is some other versioning discrepancy.
     * Runtime protobuf definitions will also be checked for compatibility
     * with pinned file descriptors to make sure there are no incompatible changes.
     * This behavior ensures that:
     * * pinned proto images are up-to-date
     * * protobuf files are carefully annotated with revision comments which
     *   are important good client UX
     * * protobuf files are changed in backwards and forwards compatible ways
     * </pre>
     *
     * <code>uint32 revision = 2 [json_name = "revision"];</code>
     */
    public fun clearRevision() {
      _builder.clearRevision()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun cosmos.app.v1alpha1.Module.PackageReference.copy(block: cosmos.app.v1alpha1.PackageReferenceKt.Dsl.() -> kotlin.Unit): cosmos.app.v1alpha1.Module.PackageReference =
  cosmos.app.v1alpha1.PackageReferenceKt.Dsl._create(this.toBuilder()).apply { block() }._build()

