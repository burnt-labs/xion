// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: amino/amino.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

// MARK: - Extension support defined in amino.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_FieldOptions {

  /// encoding describes the encoding format used by Amino for
  /// the given field. The field type is chosen to be a string for
  /// flexibility, but it should ideally be short and expected to be
  /// machine-readable, for example "base64" or "utf8_json". We
  /// highly recommend to use underscores for word separation instead of spaces.
  ///
  /// If left empty, then the Amino encoding is expected to be the same as the
  /// Protobuf one.
  ///
  /// This annotation should not be confused with the
  /// `message_encoding` one which operates on the message level.
  var Amino_encoding: String {
    get {return getExtensionValue(ext: Amino_Extensions_encoding) ?? String()}
    set {setExtensionValue(ext: Amino_Extensions_encoding, value: newValue)}
  }
  /// Returns true if extension `Amino_Extensions_encoding`
  /// has been explicitly set.
  var hasAmino_encoding: Bool {
    return hasExtensionValue(ext: Amino_Extensions_encoding)
  }
  /// Clears the value of extension `Amino_Extensions_encoding`.
  /// Subsequent reads from it will return its default value.
  mutating func clearAmino_encoding() {
    clearExtensionValue(ext: Amino_Extensions_encoding)
  }

  /// field_name sets a different field name (i.e. key name) in
  /// the amino JSON object for the given field.
  ///
  /// Example:
  ///
  /// message Foo {
  ///   string bar = 1 [(amino.field_name) = "baz"];
  /// }
  ///
  /// Then the Amino encoding of Foo will be:
  /// `{"baz":"some value"}`
  var Amino_fieldName: String {
    get {return getExtensionValue(ext: Amino_Extensions_field_name) ?? String()}
    set {setExtensionValue(ext: Amino_Extensions_field_name, value: newValue)}
  }
  /// Returns true if extension `Amino_Extensions_field_name`
  /// has been explicitly set.
  var hasAmino_fieldName: Bool {
    return hasExtensionValue(ext: Amino_Extensions_field_name)
  }
  /// Clears the value of extension `Amino_Extensions_field_name`.
  /// Subsequent reads from it will return its default value.
  mutating func clearAmino_fieldName() {
    clearExtensionValue(ext: Amino_Extensions_field_name)
  }

  /// dont_omitempty sets the field in the JSON object even if
  /// its value is empty, i.e. equal to the Golang zero value. To learn what
  /// the zero values are, see https://go.dev/ref/spec#The_zero_value.
  ///
  /// Fields default to `omitempty`, which is the default behavior when this
  /// annotation is unset. When set to true, then the field value in the
  /// JSON object will be set, i.e. not `undefined`.
  ///
  /// Example:
  ///
  /// message Foo {
  ///   string bar = 1;
  ///   string baz = 2 [(amino.dont_omitempty) = true];
  /// }
  ///
  /// f := Foo{};
  /// out := AminoJSONEncoder(&f);
  /// out == {"baz":""}
  var Amino_dontOmitempty: Bool {
    get {return getExtensionValue(ext: Amino_Extensions_dont_omitempty) ?? false}
    set {setExtensionValue(ext: Amino_Extensions_dont_omitempty, value: newValue)}
  }
  /// Returns true if extension `Amino_Extensions_dont_omitempty`
  /// has been explicitly set.
  var hasAmino_dontOmitempty: Bool {
    return hasExtensionValue(ext: Amino_Extensions_dont_omitempty)
  }
  /// Clears the value of extension `Amino_Extensions_dont_omitempty`.
  /// Subsequent reads from it will return its default value.
  mutating func clearAmino_dontOmitempty() {
    clearExtensionValue(ext: Amino_Extensions_dont_omitempty)
  }

  /// oneof_name sets the type name for the given field oneof field.  This is used
  /// by the Amino JSON encoder to encode the type of the oneof field, and must be the same string in
  /// the RegisterConcrete() method usage used to register the concrete type.
  var Amino_oneofName: String {
    get {return getExtensionValue(ext: Amino_Extensions_oneof_name) ?? String()}
    set {setExtensionValue(ext: Amino_Extensions_oneof_name, value: newValue)}
  }
  /// Returns true if extension `Amino_Extensions_oneof_name`
  /// has been explicitly set.
  var hasAmino_oneofName: Bool {
    return hasExtensionValue(ext: Amino_Extensions_oneof_name)
  }
  /// Clears the value of extension `Amino_Extensions_oneof_name`.
  /// Subsequent reads from it will return its default value.
  mutating func clearAmino_oneofName() {
    clearExtensionValue(ext: Amino_Extensions_oneof_name)
  }
}

extension SwiftProtobuf.Google_Protobuf_MessageOptions {

  /// name is the string used when registering a concrete
  /// type into the Amino type registry, via the Amino codec's
  /// `RegisterConcrete()` method. This string MUST be at most 39
  /// characters long, or else the message will be rejected by the
  /// Ledger hardware device.
  var Amino_name: String {
    get {return getExtensionValue(ext: Amino_Extensions_name) ?? String()}
    set {setExtensionValue(ext: Amino_Extensions_name, value: newValue)}
  }
  /// Returns true if extension `Amino_Extensions_name`
  /// has been explicitly set.
  var hasAmino_name: Bool {
    return hasExtensionValue(ext: Amino_Extensions_name)
  }
  /// Clears the value of extension `Amino_Extensions_name`.
  /// Subsequent reads from it will return its default value.
  mutating func clearAmino_name() {
    clearExtensionValue(ext: Amino_Extensions_name)
  }

  /// encoding describes the encoding format used by Amino for the given
  /// message. The field type is chosen to be a string for
  /// flexibility, but it should ideally be short and expected to be
  /// machine-readable, for example "base64" or "utf8_json". We
  /// highly recommend to use underscores for word separation instead of spaces.
  ///
  /// If left empty, then the Amino encoding is expected to be the same as the
  /// Protobuf one.
  ///
  /// This annotation should not be confused with the `encoding`
  /// one which operates on the field level.
  var Amino_messageEncoding: String {
    get {return getExtensionValue(ext: Amino_Extensions_message_encoding) ?? String()}
    set {setExtensionValue(ext: Amino_Extensions_message_encoding, value: newValue)}
  }
  /// Returns true if extension `Amino_Extensions_message_encoding`
  /// has been explicitly set.
  var hasAmino_messageEncoding: Bool {
    return hasExtensionValue(ext: Amino_Extensions_message_encoding)
  }
  /// Clears the value of extension `Amino_Extensions_message_encoding`.
  /// Subsequent reads from it will return its default value.
  mutating func clearAmino_messageEncoding() {
    clearExtensionValue(ext: Amino_Extensions_message_encoding)
  }

}

// MARK: - File's ExtensionMap: Amino_Amino_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let Amino_Amino_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Amino_Extensions_name,
  Amino_Extensions_message_encoding,
  Amino_Extensions_encoding,
  Amino_Extensions_field_name,
  Amino_Extensions_dont_omitempty,
  Amino_Extensions_oneof_name
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

/// name is the string used when registering a concrete
/// type into the Amino type registry, via the Amino codec's
/// `RegisterConcrete()` method. This string MUST be at most 39
/// characters long, or else the message will be rejected by the
/// Ledger hardware device.
let Amino_Extensions_name = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufString>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
  _protobuf_fieldNumber: 11110001,
  fieldName: "amino.name"
)

/// encoding describes the encoding format used by Amino for the given
/// message. The field type is chosen to be a string for
/// flexibility, but it should ideally be short and expected to be
/// machine-readable, for example "base64" or "utf8_json". We
/// highly recommend to use underscores for word separation instead of spaces.
///
/// If left empty, then the Amino encoding is expected to be the same as the
/// Protobuf one.
///
/// This annotation should not be confused with the `encoding`
/// one which operates on the field level.
let Amino_Extensions_message_encoding = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufString>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
  _protobuf_fieldNumber: 11110002,
  fieldName: "amino.message_encoding"
)

/// encoding describes the encoding format used by Amino for
/// the given field. The field type is chosen to be a string for
/// flexibility, but it should ideally be short and expected to be
/// machine-readable, for example "base64" or "utf8_json". We
/// highly recommend to use underscores for word separation instead of spaces.
///
/// If left empty, then the Amino encoding is expected to be the same as the
/// Protobuf one.
///
/// This annotation should not be confused with the
/// `message_encoding` one which operates on the message level.
let Amino_Extensions_encoding = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufString>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 11110003,
  fieldName: "amino.encoding"
)

/// field_name sets a different field name (i.e. key name) in
/// the amino JSON object for the given field.
///
/// Example:
///
/// message Foo {
///   string bar = 1 [(amino.field_name) = "baz"];
/// }
///
/// Then the Amino encoding of Foo will be:
/// `{"baz":"some value"}`
let Amino_Extensions_field_name = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufString>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 11110004,
  fieldName: "amino.field_name"
)

/// dont_omitempty sets the field in the JSON object even if
/// its value is empty, i.e. equal to the Golang zero value. To learn what
/// the zero values are, see https://go.dev/ref/spec#The_zero_value.
///
/// Fields default to `omitempty`, which is the default behavior when this
/// annotation is unset. When set to true, then the field value in the
/// JSON object will be set, i.e. not `undefined`.
///
/// Example:
///
/// message Foo {
///   string bar = 1;
///   string baz = 2 [(amino.dont_omitempty) = true];
/// }
///
/// f := Foo{};
/// out := AminoJSONEncoder(&f);
/// out == {"baz":""}
let Amino_Extensions_dont_omitempty = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufBool>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 11110005,
  fieldName: "amino.dont_omitempty"
)

/// oneof_name sets the type name for the given field oneof field.  This is used
/// by the Amino JSON encoder to encode the type of the oneof field, and must be the same string in
/// the RegisterConcrete() method usage used to register the concrete type.
let Amino_Extensions_oneof_name = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufString>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 11110006,
  fieldName: "amino.oneof_name"
)
