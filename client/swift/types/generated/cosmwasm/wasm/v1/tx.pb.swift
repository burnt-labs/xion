// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmwasm/wasm/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgStoreCode submit Wasm code to the system
struct Cosmwasm_Wasm_V1_MsgStoreCode: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the actor that signed the messages
  var sender: String = String()

  /// WASMByteCode can be raw or gzip compressed
  var wasmByteCode: Data = Data()

  /// InstantiatePermission access control to apply on contract creation,
  /// optional
  var instantiatePermission: Cosmwasm_Wasm_V1_AccessConfig {
    get {return _instantiatePermission ?? Cosmwasm_Wasm_V1_AccessConfig()}
    set {_instantiatePermission = newValue}
  }
  /// Returns true if `instantiatePermission` has been explicitly set.
  var hasInstantiatePermission: Bool {return self._instantiatePermission != nil}
  /// Clears the value of `instantiatePermission`. Subsequent reads from it will return its default value.
  mutating func clearInstantiatePermission() {self._instantiatePermission = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _instantiatePermission: Cosmwasm_Wasm_V1_AccessConfig? = nil
}

/// MsgStoreCodeResponse returns store result data.
struct Cosmwasm_Wasm_V1_MsgStoreCodeResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CodeID is the reference to the stored WASM code
  var codeID: UInt64 = 0

  /// Checksum is the sha256 hash of the stored code
  var checksum: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantiateContract create a new smart contract instance for the given
/// code id.
struct Cosmwasm_Wasm_V1_MsgInstantiateContract: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// Admin is an optional address that can execute migrations
  var admin: String = String()

  /// CodeID is the reference to the stored WASM code
  var codeID: UInt64 = 0

  /// Label is optional metadata to be stored with a contract instance.
  var label: String = String()

  /// Msg json encoded message to be passed to the contract on instantiation
  var msg: Data = Data()

  /// Funds coins that are transferred to the contract on instantiation
  var funds: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantiateContractResponse return instantiation result data
struct Cosmwasm_Wasm_V1_MsgInstantiateContractResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address is the bech32 address of the new contract instance.
  var address: String = String()

  /// Data contains bytes to returned from the contract
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantiateContract2 create a new smart contract instance for the given
/// code id with a predictable address.
struct Cosmwasm_Wasm_V1_MsgInstantiateContract2: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// Admin is an optional address that can execute migrations
  var admin: String = String()

  /// CodeID is the reference to the stored WASM code
  var codeID: UInt64 = 0

  /// Label is optional metadata to be stored with a contract instance.
  var label: String = String()

  /// Msg json encoded message to be passed to the contract on instantiation
  var msg: Data = Data()

  /// Funds coins that are transferred to the contract on instantiation
  var funds: [Cosmos_Base_V1beta1_Coin] = []

  /// Salt is an arbitrary value provided by the sender. Size can be 1 to 64.
  var salt: Data = Data()

  /// FixMsg include the msg value into the hash for the predictable address.
  /// Default is false
  var fixMsg: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantiateContract2Response return instantiation result data
struct Cosmwasm_Wasm_V1_MsgInstantiateContract2Response: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address is the bech32 address of the new contract instance.
  var address: String = String()

  /// Data contains bytes to returned from the contract
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgExecuteContract submits the given message data to a smart contract
struct Cosmwasm_Wasm_V1_MsgExecuteContract: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// Contract is the address of the smart contract
  var contract: String = String()

  /// Msg json encoded message to be passed to the contract
  var msg: Data = Data()

  /// Funds coins that are transferred to the contract on execution
  var funds: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgExecuteContractResponse returns execution result data.
struct Cosmwasm_Wasm_V1_MsgExecuteContractResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data contains bytes to returned from the contract
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgMigrateContract runs a code upgrade/ downgrade for a smart contract
struct Cosmwasm_Wasm_V1_MsgMigrateContract: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// Contract is the address of the smart contract
  var contract: String = String()

  /// CodeID references the new WASM code
  var codeID: UInt64 = 0

  /// Msg json encoded message to be passed to the contract on migration
  var msg: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgMigrateContractResponse returns contract migration result data.
struct Cosmwasm_Wasm_V1_MsgMigrateContractResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data contains same raw bytes returned as data from the wasm contract.
  /// (May be empty)
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateAdmin sets a new admin for a smart contract
struct Cosmwasm_Wasm_V1_MsgUpdateAdmin: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// NewAdmin address to be set
  var newAdmin: String = String()

  /// Contract is the address of the smart contract
  var contract: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateAdminResponse returns empty data
struct Cosmwasm_Wasm_V1_MsgUpdateAdminResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgClearAdmin removes any admin stored for a smart contract
struct Cosmwasm_Wasm_V1_MsgClearAdmin: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the actor that signed the messages
  var sender: String = String()

  /// Contract is the address of the smart contract
  var contract: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgClearAdminResponse returns empty data
struct Cosmwasm_Wasm_V1_MsgClearAdminResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateInstantiateConfig updates instantiate config for a smart contract
struct Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// CodeID references the stored WASM code
  var codeID: UInt64 = 0

  /// NewInstantiatePermission is the new access control
  var newInstantiatePermission: Cosmwasm_Wasm_V1_AccessConfig {
    get {return _newInstantiatePermission ?? Cosmwasm_Wasm_V1_AccessConfig()}
    set {_newInstantiatePermission = newValue}
  }
  /// Returns true if `newInstantiatePermission` has been explicitly set.
  var hasNewInstantiatePermission: Bool {return self._newInstantiatePermission != nil}
  /// Clears the value of `newInstantiatePermission`. Subsequent reads from it will return its default value.
  mutating func clearNewInstantiatePermission() {self._newInstantiatePermission = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newInstantiatePermission: Cosmwasm_Wasm_V1_AccessConfig? = nil
}

/// MsgUpdateInstantiateConfigResponse returns empty data
struct Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateParams is the MsgUpdateParams request type.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgUpdateParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  /// params defines the x/wasm parameters to update.
  ///
  /// NOTE: All parameters must be supplied.
  var params: Cosmwasm_Wasm_V1_Params {
    get {return _params ?? Cosmwasm_Wasm_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Cosmwasm_Wasm_V1_Params? = nil
}

/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgUpdateParamsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSudoContract is the MsgSudoContract request type.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgSudoContract: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  /// Contract is the address of the smart contract
  var contract: String = String()

  /// Msg json encoded message to be passed to the contract as sudo
  var msg: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSudoContractResponse defines the response structure for executing a
/// MsgSudoContract message.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgSudoContractResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data contains bytes to returned from the contract
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPinCodes is the MsgPinCodes request type.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgPinCodes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  /// CodeIDs references the new WASM codes
  var codeIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPinCodesResponse defines the response structure for executing a
/// MsgPinCodes message.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgPinCodesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUnpinCodes is the MsgUnpinCodes request type.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgUnpinCodes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  /// CodeIDs references the WASM codes
  var codeIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUnpinCodesResponse defines the response structure for executing a
/// MsgUnpinCodes message.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgUnpinCodesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgStoreAndInstantiateContract is the MsgStoreAndInstantiateContract
/// request type.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContract: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  /// WASMByteCode can be raw or gzip compressed
  var wasmByteCode: Data = Data()

  /// InstantiatePermission to apply on contract creation, optional
  var instantiatePermission: Cosmwasm_Wasm_V1_AccessConfig {
    get {return _instantiatePermission ?? Cosmwasm_Wasm_V1_AccessConfig()}
    set {_instantiatePermission = newValue}
  }
  /// Returns true if `instantiatePermission` has been explicitly set.
  var hasInstantiatePermission: Bool {return self._instantiatePermission != nil}
  /// Clears the value of `instantiatePermission`. Subsequent reads from it will return its default value.
  mutating func clearInstantiatePermission() {self._instantiatePermission = nil}

  /// UnpinCode code on upload, optional. As default the uploaded contract is
  /// pinned to cache.
  var unpinCode: Bool = false

  /// Admin is an optional address that can execute migrations
  var admin: String = String()

  /// Label is optional metadata to be stored with a contract instance.
  var label: String = String()

  /// Msg json encoded message to be passed to the contract on instantiation
  var msg: Data = Data()

  /// Funds coins that are transferred from the authority account to the contract
  /// on instantiation
  var funds: [Cosmos_Base_V1beta1_Coin] = []

  /// Source is the URL where the code is hosted
  var source: String = String()

  /// Builder is the docker image used to build the code deterministically, used
  /// for smart contract verification
  var builder: String = String()

  /// CodeHash is the SHA256 sum of the code outputted by builder, used for smart
  /// contract verification
  var codeHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _instantiatePermission: Cosmwasm_Wasm_V1_AccessConfig? = nil
}

/// MsgStoreAndInstantiateContractResponse defines the response structure
/// for executing a MsgStoreAndInstantiateContract message.
///
/// Since: 0.40
struct Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContractResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address is the bech32 address of the new contract instance.
  var address: String = String()

  /// Data contains bytes to returned from the contract
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddCodeUploadParamsAddresses is the
/// MsgAddCodeUploadParamsAddresses request type.
struct Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddresses: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  var addresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddCodeUploadParamsAddressesResponse defines the response
/// structure for executing a MsgAddCodeUploadParamsAddresses message.
struct Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddressesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveCodeUploadParamsAddresses is the
/// MsgRemoveCodeUploadParamsAddresses request type.
struct Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddresses: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  var addresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveCodeUploadParamsAddressesResponse defines the response
/// structure for executing a MsgRemoveCodeUploadParamsAddresses message.
struct Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddressesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgStoreAndMigrateContract is the MsgStoreAndMigrateContract
/// request type.
///
/// Since: 0.42
struct Cosmwasm_Wasm_V1_MsgStoreAndMigrateContract: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  /// WASMByteCode can be raw or gzip compressed
  var wasmByteCode: Data = Data()

  /// InstantiatePermission to apply on contract creation, optional
  var instantiatePermission: Cosmwasm_Wasm_V1_AccessConfig {
    get {return _instantiatePermission ?? Cosmwasm_Wasm_V1_AccessConfig()}
    set {_instantiatePermission = newValue}
  }
  /// Returns true if `instantiatePermission` has been explicitly set.
  var hasInstantiatePermission: Bool {return self._instantiatePermission != nil}
  /// Clears the value of `instantiatePermission`. Subsequent reads from it will return its default value.
  mutating func clearInstantiatePermission() {self._instantiatePermission = nil}

  /// Contract is the address of the smart contract
  var contract: String = String()

  /// Msg json encoded message to be passed to the contract on migration
  var msg: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _instantiatePermission: Cosmwasm_Wasm_V1_AccessConfig? = nil
}

/// MsgStoreAndMigrateContractResponse defines the response structure
/// for executing a MsgStoreAndMigrateContract message.
///
/// Since: 0.42
struct Cosmwasm_Wasm_V1_MsgStoreAndMigrateContractResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CodeID is the reference to the stored WASM code
  var codeID: UInt64 = 0

  /// Checksum is the sha256 hash of the stored code
  var checksum: Data = Data()

  /// Data contains bytes to returned from the contract
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateContractLabel sets a new label for a smart contract
struct Cosmwasm_Wasm_V1_MsgUpdateContractLabel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// NewLabel string to be set
  var newLabel: String = String()

  /// Contract is the address of the smart contract
  var contract: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateContractLabelResponse returns empty data
struct Cosmwasm_Wasm_V1_MsgUpdateContractLabelResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmwasm.wasm.v1"

extension Cosmwasm_Wasm_V1_MsgStoreCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStoreCode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "wasm_byte_code"),
    5: .standard(proto: "instantiate_permission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.wasmByteCode) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._instantiatePermission) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.wasmByteCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.wasmByteCode, fieldNumber: 2)
    }
    try { if let v = self._instantiatePermission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgStoreCode, rhs: Cosmwasm_Wasm_V1_MsgStoreCode) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.wasmByteCode != rhs.wasmByteCode {return false}
    if lhs._instantiatePermission != rhs._instantiatePermission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgStoreCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStoreCodeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_id"),
    2: .same(proto: "checksum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.checksum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 1)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularBytesField(value: self.checksum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgStoreCodeResponse, rhs: Cosmwasm_Wasm_V1_MsgStoreCodeResponse) -> Bool {
    if lhs.codeID != rhs.codeID {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgInstantiateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantiateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "admin"),
    3: .standard(proto: "code_id"),
    4: .same(proto: "label"),
    5: .same(proto: "msg"),
    6: .same(proto: "funds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.funds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 2)
    }
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 3)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 4)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 5)
    }
    if !self.funds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.funds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgInstantiateContract, rhs: Cosmwasm_Wasm_V1_MsgInstantiateContract) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.codeID != rhs.codeID {return false}
    if lhs.label != rhs.label {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.funds != rhs.funds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgInstantiateContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantiateContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgInstantiateContractResponse, rhs: Cosmwasm_Wasm_V1_MsgInstantiateContractResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgInstantiateContract2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantiateContract2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "admin"),
    3: .standard(proto: "code_id"),
    4: .same(proto: "label"),
    5: .same(proto: "msg"),
    6: .same(proto: "funds"),
    7: .same(proto: "salt"),
    8: .standard(proto: "fix_msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.funds) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.salt) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.fixMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 2)
    }
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 3)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 4)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 5)
    }
    if !self.funds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.funds, fieldNumber: 6)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularBytesField(value: self.salt, fieldNumber: 7)
    }
    if self.fixMsg != false {
      try visitor.visitSingularBoolField(value: self.fixMsg, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgInstantiateContract2, rhs: Cosmwasm_Wasm_V1_MsgInstantiateContract2) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.codeID != rhs.codeID {return false}
    if lhs.label != rhs.label {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.funds != rhs.funds {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.fixMsg != rhs.fixMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgInstantiateContract2Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantiateContract2Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgInstantiateContract2Response, rhs: Cosmwasm_Wasm_V1_MsgInstantiateContract2Response) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgExecuteContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExecuteContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "contract"),
    3: .same(proto: "msg"),
    5: .same(proto: "funds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.funds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 2)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 3)
    }
    if !self.funds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.funds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgExecuteContract, rhs: Cosmwasm_Wasm_V1_MsgExecuteContract) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.funds != rhs.funds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgExecuteContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExecuteContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgExecuteContractResponse, rhs: Cosmwasm_Wasm_V1_MsgExecuteContractResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgMigrateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMigrateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "contract"),
    3: .standard(proto: "code_id"),
    4: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 2)
    }
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 3)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgMigrateContract, rhs: Cosmwasm_Wasm_V1_MsgMigrateContract) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.codeID != rhs.codeID {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgMigrateContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMigrateContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgMigrateContractResponse, rhs: Cosmwasm_Wasm_V1_MsgMigrateContractResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateAdmin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "new_admin"),
    3: .same(proto: "contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newAdmin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.newAdmin.isEmpty {
      try visitor.visitSingularStringField(value: self.newAdmin, fieldNumber: 2)
    }
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateAdmin, rhs: Cosmwasm_Wasm_V1_MsgUpdateAdmin) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.newAdmin != rhs.newAdmin {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateAdminResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateAdminResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateAdminResponse, rhs: Cosmwasm_Wasm_V1_MsgUpdateAdminResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgClearAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClearAdmin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    3: .same(proto: "contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgClearAdmin, rhs: Cosmwasm_Wasm_V1_MsgClearAdmin) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgClearAdminResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClearAdminResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgClearAdminResponse, rhs: Cosmwasm_Wasm_V1_MsgClearAdminResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateInstantiateConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "code_id"),
    3: .standard(proto: "new_instantiate_permission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newInstantiatePermission) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 2)
    }
    try { if let v = self._newInstantiatePermission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfig, rhs: Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfig) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.codeID != rhs.codeID {return false}
    if lhs._newInstantiatePermission != rhs._newInstantiatePermission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateInstantiateConfigResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfigResponse, rhs: Cosmwasm_Wasm_V1_MsgUpdateInstantiateConfigResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateParams, rhs: Cosmwasm_Wasm_V1_MsgUpdateParams) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateParamsResponse, rhs: Cosmwasm_Wasm_V1_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgSudoContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSudoContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "contract"),
    3: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 2)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgSudoContract, rhs: Cosmwasm_Wasm_V1_MsgSudoContract) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgSudoContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSudoContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgSudoContractResponse, rhs: Cosmwasm_Wasm_V1_MsgSudoContractResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgPinCodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPinCodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .standard(proto: "code_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.codeIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.codeIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.codeIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgPinCodes, rhs: Cosmwasm_Wasm_V1_MsgPinCodes) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.codeIds != rhs.codeIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgPinCodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPinCodesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgPinCodesResponse, rhs: Cosmwasm_Wasm_V1_MsgPinCodesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUnpinCodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUnpinCodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .standard(proto: "code_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.codeIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.codeIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.codeIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUnpinCodes, rhs: Cosmwasm_Wasm_V1_MsgUnpinCodes) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.codeIds != rhs.codeIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUnpinCodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUnpinCodesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUnpinCodesResponse, rhs: Cosmwasm_Wasm_V1_MsgUnpinCodesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStoreAndInstantiateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    3: .standard(proto: "wasm_byte_code"),
    4: .standard(proto: "instantiate_permission"),
    5: .standard(proto: "unpin_code"),
    6: .same(proto: "admin"),
    7: .same(proto: "label"),
    8: .same(proto: "msg"),
    9: .same(proto: "funds"),
    10: .same(proto: "source"),
    11: .same(proto: "builder"),
    12: .standard(proto: "code_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.wasmByteCode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._instantiatePermission) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.unpinCode) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.funds) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.builder) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.codeHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.wasmByteCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.wasmByteCode, fieldNumber: 3)
    }
    try { if let v = self._instantiatePermission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.unpinCode != false {
      try visitor.visitSingularBoolField(value: self.unpinCode, fieldNumber: 5)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 6)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 7)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 8)
    }
    if !self.funds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.funds, fieldNumber: 9)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 10)
    }
    if !self.builder.isEmpty {
      try visitor.visitSingularStringField(value: self.builder, fieldNumber: 11)
    }
    if !self.codeHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeHash, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContract, rhs: Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContract) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.wasmByteCode != rhs.wasmByteCode {return false}
    if lhs._instantiatePermission != rhs._instantiatePermission {return false}
    if lhs.unpinCode != rhs.unpinCode {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.label != rhs.label {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.funds != rhs.funds {return false}
    if lhs.source != rhs.source {return false}
    if lhs.builder != rhs.builder {return false}
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStoreAndInstantiateContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContractResponse, rhs: Cosmwasm_Wasm_V1_MsgStoreAndInstantiateContractResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddresses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddCodeUploadParamsAddresses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddresses, rhs: Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddresses) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddressesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddCodeUploadParamsAddressesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddressesResponse, rhs: Cosmwasm_Wasm_V1_MsgAddCodeUploadParamsAddressesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddresses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveCodeUploadParamsAddresses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddresses, rhs: Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddresses) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddressesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveCodeUploadParamsAddressesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddressesResponse, rhs: Cosmwasm_Wasm_V1_MsgRemoveCodeUploadParamsAddressesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgStoreAndMigrateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStoreAndMigrateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .standard(proto: "wasm_byte_code"),
    3: .standard(proto: "instantiate_permission"),
    4: .same(proto: "contract"),
    5: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.wasmByteCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._instantiatePermission) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.wasmByteCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.wasmByteCode, fieldNumber: 2)
    }
    try { if let v = self._instantiatePermission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 4)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgStoreAndMigrateContract, rhs: Cosmwasm_Wasm_V1_MsgStoreAndMigrateContract) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.wasmByteCode != rhs.wasmByteCode {return false}
    if lhs._instantiatePermission != rhs._instantiatePermission {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgStoreAndMigrateContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStoreAndMigrateContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_id"),
    2: .same(proto: "checksum"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.checksum) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 1)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularBytesField(value: self.checksum, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgStoreAndMigrateContractResponse, rhs: Cosmwasm_Wasm_V1_MsgStoreAndMigrateContractResponse) -> Bool {
    if lhs.codeID != rhs.codeID {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateContractLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateContractLabel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "new_label"),
    3: .same(proto: "contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newLabel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.newLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.newLabel, fieldNumber: 2)
    }
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateContractLabel, rhs: Cosmwasm_Wasm_V1_MsgUpdateContractLabel) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.newLabel != rhs.newLabel {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmwasm_Wasm_V1_MsgUpdateContractLabelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateContractLabelResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmwasm_Wasm_V1_MsgUpdateContractLabelResponse, rhs: Cosmwasm_Wasm_V1_MsgUpdateContractLabelResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
