// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ibc/core/connection/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgConnectionOpenInit defines the msg sent by an account on Chain A to
/// initialize a connection with Chain B.
struct Ibc_Core_Connection_V1_MsgConnectionOpenInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clientID: String = String()

  var counterparty: Ibc_Core_Connection_V1_Counterparty {
    get {return _counterparty ?? Ibc_Core_Connection_V1_Counterparty()}
    set {_counterparty = newValue}
  }
  /// Returns true if `counterparty` has been explicitly set.
  var hasCounterparty: Bool {return self._counterparty != nil}
  /// Clears the value of `counterparty`. Subsequent reads from it will return its default value.
  mutating func clearCounterparty() {self._counterparty = nil}

  var version: Ibc_Core_Connection_V1_Version {
    get {return _version ?? Ibc_Core_Connection_V1_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var delayPeriod: UInt64 = 0

  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _counterparty: Ibc_Core_Connection_V1_Counterparty? = nil
  fileprivate var _version: Ibc_Core_Connection_V1_Version? = nil
}

/// MsgConnectionOpenInitResponse defines the Msg/ConnectionOpenInit response
/// type.
struct Ibc_Core_Connection_V1_MsgConnectionOpenInitResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a
/// connection on Chain B.
struct Ibc_Core_Connection_V1_MsgConnectionOpenTry: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clientID: String {
    get {return _storage._clientID}
    set {_uniqueStorage()._clientID = newValue}
  }

  /// Deprecated: this field is unused. Crossing hellos are no longer supported in core IBC.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var previousConnectionID: String {
    get {return _storage._previousConnectionID}
    set {_uniqueStorage()._previousConnectionID = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var clientState: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._clientState ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._clientState = newValue}
  }
  /// Returns true if `clientState` has been explicitly set.
  var hasClientState: Bool {return _storage._clientState != nil}
  /// Clears the value of `clientState`. Subsequent reads from it will return its default value.
  mutating func clearClientState() {_uniqueStorage()._clientState = nil}

  var counterparty: Ibc_Core_Connection_V1_Counterparty {
    get {return _storage._counterparty ?? Ibc_Core_Connection_V1_Counterparty()}
    set {_uniqueStorage()._counterparty = newValue}
  }
  /// Returns true if `counterparty` has been explicitly set.
  var hasCounterparty: Bool {return _storage._counterparty != nil}
  /// Clears the value of `counterparty`. Subsequent reads from it will return its default value.
  mutating func clearCounterparty() {_uniqueStorage()._counterparty = nil}

  var delayPeriod: UInt64 {
    get {return _storage._delayPeriod}
    set {_uniqueStorage()._delayPeriod = newValue}
  }

  var counterpartyVersions: [Ibc_Core_Connection_V1_Version] {
    get {return _storage._counterpartyVersions}
    set {_uniqueStorage()._counterpartyVersions = newValue}
  }

  var proofHeight: Ibc_Core_Client_V1_Height {
    get {return _storage._proofHeight ?? Ibc_Core_Client_V1_Height()}
    set {_uniqueStorage()._proofHeight = newValue}
  }
  /// Returns true if `proofHeight` has been explicitly set.
  var hasProofHeight: Bool {return _storage._proofHeight != nil}
  /// Clears the value of `proofHeight`. Subsequent reads from it will return its default value.
  mutating func clearProofHeight() {_uniqueStorage()._proofHeight = nil}

  /// proof of the initialization the connection on Chain A: `UNITIALIZED ->
  /// INIT`
  var proofInit: Data {
    get {return _storage._proofInit}
    set {_uniqueStorage()._proofInit = newValue}
  }

  /// proof of client state included in message
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var proofClient: Data {
    get {return _storage._proofClient}
    set {_uniqueStorage()._proofClient = newValue}
  }

  /// proof of client consensus state
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var proofConsensus: Data {
    get {return _storage._proofConsensus}
    set {_uniqueStorage()._proofConsensus = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var consensusHeight: Ibc_Core_Client_V1_Height {
    get {return _storage._consensusHeight ?? Ibc_Core_Client_V1_Height()}
    set {_uniqueStorage()._consensusHeight = newValue}
  }
  /// Returns true if `consensusHeight` has been explicitly set.
  var hasConsensusHeight: Bool {return _storage._consensusHeight != nil}
  /// Clears the value of `consensusHeight`. Subsequent reads from it will return its default value.
  mutating func clearConsensusHeight() {_uniqueStorage()._consensusHeight = nil}

  var signer: String {
    get {return _storage._signer}
    set {_uniqueStorage()._signer = newValue}
  }

  /// optional proof data for host state machines that are unable to introspect their own consensus state
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var hostConsensusStateProof: Data {
    get {return _storage._hostConsensusStateProof}
    set {_uniqueStorage()._hostConsensusStateProof = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MsgConnectionOpenTryResponse defines the Msg/ConnectionOpenTry response type.
struct Ibc_Core_Connection_V1_MsgConnectionOpenTryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to
/// acknowledge the change of connection state to TRYOPEN on Chain B.
struct Ibc_Core_Connection_V1_MsgConnectionOpenAck: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String = String()

  var counterpartyConnectionID: String = String()

  var version: Ibc_Core_Connection_V1_Version {
    get {return _version ?? Ibc_Core_Connection_V1_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var clientState: SwiftProtobuf.Google_Protobuf_Any {
    get {return _clientState ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_clientState = newValue}
  }
  /// Returns true if `clientState` has been explicitly set.
  var hasClientState: Bool {return self._clientState != nil}
  /// Clears the value of `clientState`. Subsequent reads from it will return its default value.
  mutating func clearClientState() {self._clientState = nil}

  var proofHeight: Ibc_Core_Client_V1_Height {
    get {return _proofHeight ?? Ibc_Core_Client_V1_Height()}
    set {_proofHeight = newValue}
  }
  /// Returns true if `proofHeight` has been explicitly set.
  var hasProofHeight: Bool {return self._proofHeight != nil}
  /// Clears the value of `proofHeight`. Subsequent reads from it will return its default value.
  mutating func clearProofHeight() {self._proofHeight = nil}

  /// proof of the initialization the connection on Chain B: `UNITIALIZED ->
  /// TRYOPEN`
  var proofTry: Data = Data()

  /// proof of client state included in message
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var proofClient: Data = Data()

  /// proof of client consensus state
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var proofConsensus: Data = Data()

  /// NOTE: This field was marked as deprecated in the .proto file.
  var consensusHeight: Ibc_Core_Client_V1_Height {
    get {return _consensusHeight ?? Ibc_Core_Client_V1_Height()}
    set {_consensusHeight = newValue}
  }
  /// Returns true if `consensusHeight` has been explicitly set.
  var hasConsensusHeight: Bool {return self._consensusHeight != nil}
  /// Clears the value of `consensusHeight`. Subsequent reads from it will return its default value.
  mutating func clearConsensusHeight() {self._consensusHeight = nil}

  var signer: String = String()

  /// optional proof data for host state machines that are unable to introspect their own consensus state
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var hostConsensusStateProof: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Ibc_Core_Connection_V1_Version? = nil
  fileprivate var _clientState: SwiftProtobuf.Google_Protobuf_Any? = nil
  fileprivate var _proofHeight: Ibc_Core_Client_V1_Height? = nil
  fileprivate var _consensusHeight: Ibc_Core_Client_V1_Height? = nil
}

/// MsgConnectionOpenAckResponse defines the Msg/ConnectionOpenAck response type.
struct Ibc_Core_Connection_V1_MsgConnectionOpenAckResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to
/// acknowledge the change of connection state to OPEN on Chain A.
struct Ibc_Core_Connection_V1_MsgConnectionOpenConfirm: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String = String()

  /// proof for the change of the connection state on Chain A: `INIT -> OPEN`
  var proofAck: Data = Data()

  var proofHeight: Ibc_Core_Client_V1_Height {
    get {return _proofHeight ?? Ibc_Core_Client_V1_Height()}
    set {_proofHeight = newValue}
  }
  /// Returns true if `proofHeight` has been explicitly set.
  var hasProofHeight: Bool {return self._proofHeight != nil}
  /// Clears the value of `proofHeight`. Subsequent reads from it will return its default value.
  mutating func clearProofHeight() {self._proofHeight = nil}

  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proofHeight: Ibc_Core_Client_V1_Height? = nil
}

/// MsgConnectionOpenConfirmResponse defines the Msg/ConnectionOpenConfirm
/// response type.
struct Ibc_Core_Connection_V1_MsgConnectionOpenConfirmResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateParams defines the sdk.Msg type to update the connection parameters.
struct Ibc_Core_Connection_V1_MsgUpdateParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signer address
  var signer: String = String()

  /// params defines the connection parameters to update.
  ///
  /// NOTE: All parameters must be supplied.
  var params: Ibc_Core_Connection_V1_Params {
    get {return _params ?? Ibc_Core_Connection_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Ibc_Core_Connection_V1_Params? = nil
}

/// MsgUpdateParamsResponse defines the MsgUpdateParams response type.
struct Ibc_Core_Connection_V1_MsgUpdateParamsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ibc.core.connection.v1"

extension Ibc_Core_Connection_V1_MsgConnectionOpenInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "counterparty"),
    3: .same(proto: "version"),
    4: .standard(proto: "delay_period"),
    5: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._counterparty) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.delayPeriod) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    try { if let v = self._counterparty {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.delayPeriod != 0 {
      try visitor.visitSingularUInt64Field(value: self.delayPeriod, fieldNumber: 4)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenInit, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenInit) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs._counterparty != rhs._counterparty {return false}
    if lhs._version != rhs._version {return false}
    if lhs.delayPeriod != rhs.delayPeriod {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgConnectionOpenInitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenInitResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenInitResponse, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenInitResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgConnectionOpenTry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenTry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "previous_connection_id"),
    3: .standard(proto: "client_state"),
    4: .same(proto: "counterparty"),
    5: .standard(proto: "delay_period"),
    6: .standard(proto: "counterparty_versions"),
    7: .standard(proto: "proof_height"),
    8: .standard(proto: "proof_init"),
    9: .standard(proto: "proof_client"),
    10: .standard(proto: "proof_consensus"),
    11: .standard(proto: "consensus_height"),
    12: .same(proto: "signer"),
    13: .standard(proto: "host_consensus_state_proof"),
  ]

  fileprivate class _StorageClass {
    var _clientID: String = String()
    var _previousConnectionID: String = String()
    var _clientState: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _counterparty: Ibc_Core_Connection_V1_Counterparty? = nil
    var _delayPeriod: UInt64 = 0
    var _counterpartyVersions: [Ibc_Core_Connection_V1_Version] = []
    var _proofHeight: Ibc_Core_Client_V1_Height? = nil
    var _proofInit: Data = Data()
    var _proofClient: Data = Data()
    var _proofConsensus: Data = Data()
    var _consensusHeight: Ibc_Core_Client_V1_Height? = nil
    var _signer: String = String()
    var _hostConsensusStateProof: Data = Data()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _clientID = source._clientID
      _previousConnectionID = source._previousConnectionID
      _clientState = source._clientState
      _counterparty = source._counterparty
      _delayPeriod = source._delayPeriod
      _counterpartyVersions = source._counterpartyVersions
      _proofHeight = source._proofHeight
      _proofInit = source._proofInit
      _proofClient = source._proofClient
      _proofConsensus = source._proofConsensus
      _consensusHeight = source._consensusHeight
      _signer = source._signer
      _hostConsensusStateProof = source._hostConsensusStateProof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._clientID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._previousConnectionID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._clientState) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._counterparty) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._delayPeriod) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._counterpartyVersions) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._proofHeight) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._proofInit) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._proofClient) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._proofConsensus) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._consensusHeight) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._signer) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._hostConsensusStateProof) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 1)
      }
      if !_storage._previousConnectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._previousConnectionID, fieldNumber: 2)
      }
      try { if let v = _storage._clientState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._counterparty {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._delayPeriod != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._delayPeriod, fieldNumber: 5)
      }
      if !_storage._counterpartyVersions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._counterpartyVersions, fieldNumber: 6)
      }
      try { if let v = _storage._proofHeight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._proofInit.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proofInit, fieldNumber: 8)
      }
      if !_storage._proofClient.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proofClient, fieldNumber: 9)
      }
      if !_storage._proofConsensus.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proofConsensus, fieldNumber: 10)
      }
      try { if let v = _storage._consensusHeight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._signer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._signer, fieldNumber: 12)
      }
      if !_storage._hostConsensusStateProof.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hostConsensusStateProof, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenTry, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenTry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._previousConnectionID != rhs_storage._previousConnectionID {return false}
        if _storage._clientState != rhs_storage._clientState {return false}
        if _storage._counterparty != rhs_storage._counterparty {return false}
        if _storage._delayPeriod != rhs_storage._delayPeriod {return false}
        if _storage._counterpartyVersions != rhs_storage._counterpartyVersions {return false}
        if _storage._proofHeight != rhs_storage._proofHeight {return false}
        if _storage._proofInit != rhs_storage._proofInit {return false}
        if _storage._proofClient != rhs_storage._proofClient {return false}
        if _storage._proofConsensus != rhs_storage._proofConsensus {return false}
        if _storage._consensusHeight != rhs_storage._consensusHeight {return false}
        if _storage._signer != rhs_storage._signer {return false}
        if _storage._hostConsensusStateProof != rhs_storage._hostConsensusStateProof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgConnectionOpenTryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenTryResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenTryResponse, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenTryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgConnectionOpenAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .standard(proto: "counterparty_connection_id"),
    3: .same(proto: "version"),
    4: .standard(proto: "client_state"),
    5: .standard(proto: "proof_height"),
    6: .standard(proto: "proof_try"),
    7: .standard(proto: "proof_client"),
    8: .standard(proto: "proof_consensus"),
    9: .standard(proto: "consensus_height"),
    10: .same(proto: "signer"),
    11: .standard(proto: "host_consensus_state_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.counterpartyConnectionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientState) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._proofHeight) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.proofTry) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.proofClient) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proofConsensus) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._consensusHeight) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.hostConsensusStateProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    if !self.counterpartyConnectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.counterpartyConnectionID, fieldNumber: 2)
    }
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._clientState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._proofHeight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.proofTry.isEmpty {
      try visitor.visitSingularBytesField(value: self.proofTry, fieldNumber: 6)
    }
    if !self.proofClient.isEmpty {
      try visitor.visitSingularBytesField(value: self.proofClient, fieldNumber: 7)
    }
    if !self.proofConsensus.isEmpty {
      try visitor.visitSingularBytesField(value: self.proofConsensus, fieldNumber: 8)
    }
    try { if let v = self._consensusHeight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 10)
    }
    if !self.hostConsensusStateProof.isEmpty {
      try visitor.visitSingularBytesField(value: self.hostConsensusStateProof, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenAck, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenAck) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.counterpartyConnectionID != rhs.counterpartyConnectionID {return false}
    if lhs._version != rhs._version {return false}
    if lhs._clientState != rhs._clientState {return false}
    if lhs._proofHeight != rhs._proofHeight {return false}
    if lhs.proofTry != rhs.proofTry {return false}
    if lhs.proofClient != rhs.proofClient {return false}
    if lhs.proofConsensus != rhs.proofConsensus {return false}
    if lhs._consensusHeight != rhs._consensusHeight {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.hostConsensusStateProof != rhs.hostConsensusStateProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgConnectionOpenAckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenAckResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenAckResponse, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenAckResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgConnectionOpenConfirm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenConfirm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .standard(proto: "proof_ack"),
    3: .standard(proto: "proof_height"),
    4: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.proofAck) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._proofHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    if !self.proofAck.isEmpty {
      try visitor.visitSingularBytesField(value: self.proofAck, fieldNumber: 2)
    }
    try { if let v = self._proofHeight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenConfirm, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenConfirm) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.proofAck != rhs.proofAck {return false}
    if lhs._proofHeight != rhs._proofHeight {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgConnectionOpenConfirmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConnectionOpenConfirmResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgConnectionOpenConfirmResponse, rhs: Ibc_Core_Connection_V1_MsgConnectionOpenConfirmResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgUpdateParams, rhs: Ibc_Core_Connection_V1_MsgUpdateParams) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Connection_V1_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Connection_V1_MsgUpdateParamsResponse, rhs: Ibc_Core_Connection_V1_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
