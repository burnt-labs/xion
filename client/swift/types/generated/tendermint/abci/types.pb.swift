// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tendermint/abci/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Tendermint_Abci_CheckTxType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case new // = 0
  case recheck // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .new
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .new
    case 1: self = .recheck
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .new: return 0
    case .recheck: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Tendermint_Abci_CheckTxType] = [
    .new,
    .recheck,
  ]

}

enum Tendermint_Abci_MisbehaviorType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case duplicateVote // = 1
  case lightClientAttack // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .duplicateVote
    case 2: self = .lightClientAttack
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .duplicateVote: return 1
    case .lightClientAttack: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Tendermint_Abci_MisbehaviorType] = [
    .unknown,
    .duplicateVote,
    .lightClientAttack,
  ]

}

struct Tendermint_Abci_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Tendermint_Abci_Request.OneOf_Value? = nil

  var echo: Tendermint_Abci_RequestEcho {
    get {
      if case .echo(let v)? = value {return v}
      return Tendermint_Abci_RequestEcho()
    }
    set {value = .echo(newValue)}
  }

  var flush: Tendermint_Abci_RequestFlush {
    get {
      if case .flush(let v)? = value {return v}
      return Tendermint_Abci_RequestFlush()
    }
    set {value = .flush(newValue)}
  }

  var info: Tendermint_Abci_RequestInfo {
    get {
      if case .info(let v)? = value {return v}
      return Tendermint_Abci_RequestInfo()
    }
    set {value = .info(newValue)}
  }

  var initChain: Tendermint_Abci_RequestInitChain {
    get {
      if case .initChain(let v)? = value {return v}
      return Tendermint_Abci_RequestInitChain()
    }
    set {value = .initChain(newValue)}
  }

  var query: Tendermint_Abci_RequestQuery {
    get {
      if case .query(let v)? = value {return v}
      return Tendermint_Abci_RequestQuery()
    }
    set {value = .query(newValue)}
  }

  var checkTx: Tendermint_Abci_RequestCheckTx {
    get {
      if case .checkTx(let v)? = value {return v}
      return Tendermint_Abci_RequestCheckTx()
    }
    set {value = .checkTx(newValue)}
  }

  var commit: Tendermint_Abci_RequestCommit {
    get {
      if case .commit(let v)? = value {return v}
      return Tendermint_Abci_RequestCommit()
    }
    set {value = .commit(newValue)}
  }

  var listSnapshots: Tendermint_Abci_RequestListSnapshots {
    get {
      if case .listSnapshots(let v)? = value {return v}
      return Tendermint_Abci_RequestListSnapshots()
    }
    set {value = .listSnapshots(newValue)}
  }

  var offerSnapshot: Tendermint_Abci_RequestOfferSnapshot {
    get {
      if case .offerSnapshot(let v)? = value {return v}
      return Tendermint_Abci_RequestOfferSnapshot()
    }
    set {value = .offerSnapshot(newValue)}
  }

  var loadSnapshotChunk: Tendermint_Abci_RequestLoadSnapshotChunk {
    get {
      if case .loadSnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_RequestLoadSnapshotChunk()
    }
    set {value = .loadSnapshotChunk(newValue)}
  }

  var applySnapshotChunk: Tendermint_Abci_RequestApplySnapshotChunk {
    get {
      if case .applySnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_RequestApplySnapshotChunk()
    }
    set {value = .applySnapshotChunk(newValue)}
  }

  var prepareProposal: Tendermint_Abci_RequestPrepareProposal {
    get {
      if case .prepareProposal(let v)? = value {return v}
      return Tendermint_Abci_RequestPrepareProposal()
    }
    set {value = .prepareProposal(newValue)}
  }

  var processProposal: Tendermint_Abci_RequestProcessProposal {
    get {
      if case .processProposal(let v)? = value {return v}
      return Tendermint_Abci_RequestProcessProposal()
    }
    set {value = .processProposal(newValue)}
  }

  var extendVote: Tendermint_Abci_RequestExtendVote {
    get {
      if case .extendVote(let v)? = value {return v}
      return Tendermint_Abci_RequestExtendVote()
    }
    set {value = .extendVote(newValue)}
  }

  var verifyVoteExtension: Tendermint_Abci_RequestVerifyVoteExtension {
    get {
      if case .verifyVoteExtension(let v)? = value {return v}
      return Tendermint_Abci_RequestVerifyVoteExtension()
    }
    set {value = .verifyVoteExtension(newValue)}
  }

  var finalizeBlock: Tendermint_Abci_RequestFinalizeBlock {
    get {
      if case .finalizeBlock(let v)? = value {return v}
      return Tendermint_Abci_RequestFinalizeBlock()
    }
    set {value = .finalizeBlock(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case echo(Tendermint_Abci_RequestEcho)
    case flush(Tendermint_Abci_RequestFlush)
    case info(Tendermint_Abci_RequestInfo)
    case initChain(Tendermint_Abci_RequestInitChain)
    case query(Tendermint_Abci_RequestQuery)
    case checkTx(Tendermint_Abci_RequestCheckTx)
    case commit(Tendermint_Abci_RequestCommit)
    case listSnapshots(Tendermint_Abci_RequestListSnapshots)
    case offerSnapshot(Tendermint_Abci_RequestOfferSnapshot)
    case loadSnapshotChunk(Tendermint_Abci_RequestLoadSnapshotChunk)
    case applySnapshotChunk(Tendermint_Abci_RequestApplySnapshotChunk)
    case prepareProposal(Tendermint_Abci_RequestPrepareProposal)
    case processProposal(Tendermint_Abci_RequestProcessProposal)
    case extendVote(Tendermint_Abci_RequestExtendVote)
    case verifyVoteExtension(Tendermint_Abci_RequestVerifyVoteExtension)
    case finalizeBlock(Tendermint_Abci_RequestFinalizeBlock)

  }

  init() {}
}

struct Tendermint_Abci_RequestEcho: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestFlush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var blockVersion: UInt64 = 0

  var p2PVersion: UInt64 = 0

  var abciVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestInitChain: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var chainID: String = String()

  var consensusParams: Tendermint_Types_ConsensusParams {
    get {return _consensusParams ?? Tendermint_Types_ConsensusParams()}
    set {_consensusParams = newValue}
  }
  /// Returns true if `consensusParams` has been explicitly set.
  var hasConsensusParams: Bool {return self._consensusParams != nil}
  /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
  mutating func clearConsensusParams() {self._consensusParams = nil}

  var validators: [Tendermint_Abci_ValidatorUpdate] = []

  var appStateBytes: Data = Data()

  var initialHeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _consensusParams: Tendermint_Types_ConsensusParams? = nil
}

struct Tendermint_Abci_RequestQuery: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var path: String = String()

  var height: Int64 = 0

  var prove: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestCheckTx: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Data = Data()

  var type: Tendermint_Abci_CheckTxType = .new

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestCommit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// lists available snapshots
struct Tendermint_Abci_RequestListSnapshots: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// offers a snapshot to the application
struct Tendermint_Abci_RequestOfferSnapshot: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// snapshot offered by peers
  var snapshot: Tendermint_Abci_Snapshot {
    get {return _snapshot ?? Tendermint_Abci_Snapshot()}
    set {_snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  var hasSnapshot: Bool {return self._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  mutating func clearSnapshot() {self._snapshot = nil}

  /// light client-verified app hash for snapshot height
  var appHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _snapshot: Tendermint_Abci_Snapshot? = nil
}

/// loads a snapshot chunk
struct Tendermint_Abci_RequestLoadSnapshotChunk: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt64 = 0

  var format: UInt32 = 0

  var chunk: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Applies a snapshot chunk
struct Tendermint_Abci_RequestApplySnapshotChunk: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var chunk: Data = Data()

  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestPrepareProposal: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the modified transactions cannot exceed this size.
  var maxTxBytes: Int64 = 0

  /// txs is an array of transactions that will be included in a block,
  /// sent to the app for possible modifications.
  var txs: [Data] = []

  var localLastCommit: Tendermint_Abci_ExtendedCommitInfo {
    get {return _localLastCommit ?? Tendermint_Abci_ExtendedCommitInfo()}
    set {_localLastCommit = newValue}
  }
  /// Returns true if `localLastCommit` has been explicitly set.
  var hasLocalLastCommit: Bool {return self._localLastCommit != nil}
  /// Clears the value of `localLastCommit`. Subsequent reads from it will return its default value.
  mutating func clearLocalLastCommit() {self._localLastCommit = nil}

  var misbehavior: [Tendermint_Abci_Misbehavior] = []

  var height: Int64 = 0

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var nextValidatorsHash: Data = Data()

  /// address of the public key of the validator proposing the block.
  var proposerAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _localLastCommit: Tendermint_Abci_ExtendedCommitInfo? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Tendermint_Abci_RequestProcessProposal: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txs: [Data] = []

  var proposedLastCommit: Tendermint_Abci_CommitInfo {
    get {return _proposedLastCommit ?? Tendermint_Abci_CommitInfo()}
    set {_proposedLastCommit = newValue}
  }
  /// Returns true if `proposedLastCommit` has been explicitly set.
  var hasProposedLastCommit: Bool {return self._proposedLastCommit != nil}
  /// Clears the value of `proposedLastCommit`. Subsequent reads from it will return its default value.
  mutating func clearProposedLastCommit() {self._proposedLastCommit = nil}

  var misbehavior: [Tendermint_Abci_Misbehavior] = []

  /// hash is the merkle root hash of the fields of the proposed block.
  var hash: Data = Data()

  var height: Int64 = 0

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var nextValidatorsHash: Data = Data()

  /// address of the public key of the original proposer of the block.
  var proposerAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proposedLastCommit: Tendermint_Abci_CommitInfo? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Extends a vote with application-injected data
struct Tendermint_Abci_RequestExtendVote: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of the block that this vote may be referring to
  var hash: Data = Data()

  /// the height of the extended vote
  var height: Int64 = 0

  /// info of the block that this vote may be referring to
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var txs: [Data] = []

  var proposedLastCommit: Tendermint_Abci_CommitInfo {
    get {return _proposedLastCommit ?? Tendermint_Abci_CommitInfo()}
    set {_proposedLastCommit = newValue}
  }
  /// Returns true if `proposedLastCommit` has been explicitly set.
  var hasProposedLastCommit: Bool {return self._proposedLastCommit != nil}
  /// Clears the value of `proposedLastCommit`. Subsequent reads from it will return its default value.
  mutating func clearProposedLastCommit() {self._proposedLastCommit = nil}

  var misbehavior: [Tendermint_Abci_Misbehavior] = []

  var nextValidatorsHash: Data = Data()

  /// address of the public key of the original proposer of the block.
  var proposerAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _proposedLastCommit: Tendermint_Abci_CommitInfo? = nil
}

/// Verify the vote extension
struct Tendermint_Abci_RequestVerifyVoteExtension: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of the block that this received vote corresponds to
  var hash: Data = Data()

  /// the validator that signed the vote extension
  var validatorAddress: Data = Data()

  var height: Int64 = 0

  var voteExtension: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestFinalizeBlock: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txs: [Data] = []

  var decidedLastCommit: Tendermint_Abci_CommitInfo {
    get {return _decidedLastCommit ?? Tendermint_Abci_CommitInfo()}
    set {_decidedLastCommit = newValue}
  }
  /// Returns true if `decidedLastCommit` has been explicitly set.
  var hasDecidedLastCommit: Bool {return self._decidedLastCommit != nil}
  /// Clears the value of `decidedLastCommit`. Subsequent reads from it will return its default value.
  mutating func clearDecidedLastCommit() {self._decidedLastCommit = nil}

  var misbehavior: [Tendermint_Abci_Misbehavior] = []

  /// hash is the merkle root hash of the fields of the decided block.
  var hash: Data = Data()

  var height: Int64 = 0

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var nextValidatorsHash: Data = Data()

  /// proposer_address is the address of the public key of the original proposer of the block.
  var proposerAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _decidedLastCommit: Tendermint_Abci_CommitInfo? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Tendermint_Abci_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Tendermint_Abci_Response.OneOf_Value? = nil

  var exception: Tendermint_Abci_ResponseException {
    get {
      if case .exception(let v)? = value {return v}
      return Tendermint_Abci_ResponseException()
    }
    set {value = .exception(newValue)}
  }

  var echo: Tendermint_Abci_ResponseEcho {
    get {
      if case .echo(let v)? = value {return v}
      return Tendermint_Abci_ResponseEcho()
    }
    set {value = .echo(newValue)}
  }

  var flush: Tendermint_Abci_ResponseFlush {
    get {
      if case .flush(let v)? = value {return v}
      return Tendermint_Abci_ResponseFlush()
    }
    set {value = .flush(newValue)}
  }

  var info: Tendermint_Abci_ResponseInfo {
    get {
      if case .info(let v)? = value {return v}
      return Tendermint_Abci_ResponseInfo()
    }
    set {value = .info(newValue)}
  }

  var initChain: Tendermint_Abci_ResponseInitChain {
    get {
      if case .initChain(let v)? = value {return v}
      return Tendermint_Abci_ResponseInitChain()
    }
    set {value = .initChain(newValue)}
  }

  var query: Tendermint_Abci_ResponseQuery {
    get {
      if case .query(let v)? = value {return v}
      return Tendermint_Abci_ResponseQuery()
    }
    set {value = .query(newValue)}
  }

  var checkTx: Tendermint_Abci_ResponseCheckTx {
    get {
      if case .checkTx(let v)? = value {return v}
      return Tendermint_Abci_ResponseCheckTx()
    }
    set {value = .checkTx(newValue)}
  }

  var commit: Tendermint_Abci_ResponseCommit {
    get {
      if case .commit(let v)? = value {return v}
      return Tendermint_Abci_ResponseCommit()
    }
    set {value = .commit(newValue)}
  }

  var listSnapshots: Tendermint_Abci_ResponseListSnapshots {
    get {
      if case .listSnapshots(let v)? = value {return v}
      return Tendermint_Abci_ResponseListSnapshots()
    }
    set {value = .listSnapshots(newValue)}
  }

  var offerSnapshot: Tendermint_Abci_ResponseOfferSnapshot {
    get {
      if case .offerSnapshot(let v)? = value {return v}
      return Tendermint_Abci_ResponseOfferSnapshot()
    }
    set {value = .offerSnapshot(newValue)}
  }

  var loadSnapshotChunk: Tendermint_Abci_ResponseLoadSnapshotChunk {
    get {
      if case .loadSnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_ResponseLoadSnapshotChunk()
    }
    set {value = .loadSnapshotChunk(newValue)}
  }

  var applySnapshotChunk: Tendermint_Abci_ResponseApplySnapshotChunk {
    get {
      if case .applySnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_ResponseApplySnapshotChunk()
    }
    set {value = .applySnapshotChunk(newValue)}
  }

  var prepareProposal: Tendermint_Abci_ResponsePrepareProposal {
    get {
      if case .prepareProposal(let v)? = value {return v}
      return Tendermint_Abci_ResponsePrepareProposal()
    }
    set {value = .prepareProposal(newValue)}
  }

  var processProposal: Tendermint_Abci_ResponseProcessProposal {
    get {
      if case .processProposal(let v)? = value {return v}
      return Tendermint_Abci_ResponseProcessProposal()
    }
    set {value = .processProposal(newValue)}
  }

  var extendVote: Tendermint_Abci_ResponseExtendVote {
    get {
      if case .extendVote(let v)? = value {return v}
      return Tendermint_Abci_ResponseExtendVote()
    }
    set {value = .extendVote(newValue)}
  }

  var verifyVoteExtension: Tendermint_Abci_ResponseVerifyVoteExtension {
    get {
      if case .verifyVoteExtension(let v)? = value {return v}
      return Tendermint_Abci_ResponseVerifyVoteExtension()
    }
    set {value = .verifyVoteExtension(newValue)}
  }

  var finalizeBlock: Tendermint_Abci_ResponseFinalizeBlock {
    get {
      if case .finalizeBlock(let v)? = value {return v}
      return Tendermint_Abci_ResponseFinalizeBlock()
    }
    set {value = .finalizeBlock(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case exception(Tendermint_Abci_ResponseException)
    case echo(Tendermint_Abci_ResponseEcho)
    case flush(Tendermint_Abci_ResponseFlush)
    case info(Tendermint_Abci_ResponseInfo)
    case initChain(Tendermint_Abci_ResponseInitChain)
    case query(Tendermint_Abci_ResponseQuery)
    case checkTx(Tendermint_Abci_ResponseCheckTx)
    case commit(Tendermint_Abci_ResponseCommit)
    case listSnapshots(Tendermint_Abci_ResponseListSnapshots)
    case offerSnapshot(Tendermint_Abci_ResponseOfferSnapshot)
    case loadSnapshotChunk(Tendermint_Abci_ResponseLoadSnapshotChunk)
    case applySnapshotChunk(Tendermint_Abci_ResponseApplySnapshotChunk)
    case prepareProposal(Tendermint_Abci_ResponsePrepareProposal)
    case processProposal(Tendermint_Abci_ResponseProcessProposal)
    case extendVote(Tendermint_Abci_ResponseExtendVote)
    case verifyVoteExtension(Tendermint_Abci_ResponseVerifyVoteExtension)
    case finalizeBlock(Tendermint_Abci_ResponseFinalizeBlock)

  }

  init() {}
}

/// nondeterministic
struct Tendermint_Abci_ResponseException: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseEcho: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseFlush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: String = String()

  var version: String = String()

  var appVersion: UInt64 = 0

  var lastBlockHeight: Int64 = 0

  var lastBlockAppHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseInitChain: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var consensusParams: Tendermint_Types_ConsensusParams {
    get {return _consensusParams ?? Tendermint_Types_ConsensusParams()}
    set {_consensusParams = newValue}
  }
  /// Returns true if `consensusParams` has been explicitly set.
  var hasConsensusParams: Bool {return self._consensusParams != nil}
  /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
  mutating func clearConsensusParams() {self._consensusParams = nil}

  var validators: [Tendermint_Abci_ValidatorUpdate] = []

  var appHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _consensusParams: Tendermint_Types_ConsensusParams? = nil
}

struct Tendermint_Abci_ResponseQuery: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  /// bytes data = 2; // use "value" instead.
  var log: String = String()

  /// nondeterministic
  var info: String = String()

  var index: Int64 = 0

  var key: Data = Data()

  var value: Data = Data()

  var proofOps: Tendermint_Crypto_ProofOps {
    get {return _proofOps ?? Tendermint_Crypto_ProofOps()}
    set {_proofOps = newValue}
  }
  /// Returns true if `proofOps` has been explicitly set.
  var hasProofOps: Bool {return self._proofOps != nil}
  /// Clears the value of `proofOps`. Subsequent reads from it will return its default value.
  mutating func clearProofOps() {self._proofOps = nil}

  var height: Int64 = 0

  var codespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proofOps: Tendermint_Crypto_ProofOps? = nil
}

struct Tendermint_Abci_ResponseCheckTx: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var data: Data = Data()

  /// nondeterministic
  var log: String = String()

  /// nondeterministic
  var info: String = String()

  var gasWanted: Int64 = 0

  var gasUsed: Int64 = 0

  var events: [Tendermint_Abci_Event] = []

  var codespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseCommit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var retainHeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseListSnapshots: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var snapshots: [Tendermint_Abci_Snapshot] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseOfferSnapshot: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Tendermint_Abci_ResponseOfferSnapshot.Result = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unknown result, abort all snapshot restoration
    case unknown // = 0

    /// Snapshot accepted, apply chunks
    case accept // = 1

    /// Abort all snapshot restoration
    case abort // = 2

    /// Reject this specific snapshot, try others
    case reject // = 3

    /// Reject all snapshots of this format, try others
    case rejectFormat // = 4

    /// Reject all snapshots from the sender(s), try others
    case rejectSender // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .abort
      case 3: self = .reject
      case 4: self = .rejectFormat
      case 5: self = .rejectSender
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .abort: return 2
      case .reject: return 3
      case .rejectFormat: return 4
      case .rejectSender: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Tendermint_Abci_ResponseOfferSnapshot.Result] = [
      .unknown,
      .accept,
      .abort,
      .reject,
      .rejectFormat,
      .rejectSender,
    ]

  }

  init() {}
}

struct Tendermint_Abci_ResponseLoadSnapshotChunk: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chunk: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseApplySnapshotChunk: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Tendermint_Abci_ResponseApplySnapshotChunk.Result = .unknown

  /// Chunks to refetch and reapply
  var refetchChunks: [UInt32] = []

  /// Chunk senders to reject and ban
  var rejectSenders: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unknown result, abort all snapshot restoration
    case unknown // = 0

    /// Chunk successfully accepted
    case accept // = 1

    /// Abort all snapshot restoration
    case abort // = 2

    /// Retry chunk (combine with refetch and reject)
    case retry // = 3

    /// Retry snapshot (combine with refetch and reject)
    case retrySnapshot // = 4

    /// Reject this snapshot, try others
    case rejectSnapshot // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .abort
      case 3: self = .retry
      case 4: self = .retrySnapshot
      case 5: self = .rejectSnapshot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .abort: return 2
      case .retry: return 3
      case .retrySnapshot: return 4
      case .rejectSnapshot: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Tendermint_Abci_ResponseApplySnapshotChunk.Result] = [
      .unknown,
      .accept,
      .abort,
      .retry,
      .retrySnapshot,
      .rejectSnapshot,
    ]

  }

  init() {}
}

struct Tendermint_Abci_ResponsePrepareProposal: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseProcessProposal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Tendermint_Abci_ResponseProcessProposal.ProposalStatus = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ProposalStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case accept // = 1
    case reject // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .reject
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .reject: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Tendermint_Abci_ResponseProcessProposal.ProposalStatus] = [
      .unknown,
      .accept,
      .reject,
    ]

  }

  init() {}
}

struct Tendermint_Abci_ResponseExtendVote: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var voteExtension: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseVerifyVoteExtension: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum VerifyStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case accept // = 1

    /// Rejecting the vote extension will reject the entire precommit by the sender.
    /// Incorrectly implementing this thus has liveness implications as it may affect
    /// CometBFT's ability to receive 2/3+ valid votes to finalize the block.
    /// Honest nodes should never be rejected.
    case reject // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .reject
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .reject: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus] = [
      .unknown,
      .accept,
      .reject,
    ]

  }

  init() {}
}

struct Tendermint_Abci_ResponseFinalizeBlock: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// set of block events emmitted as part of executing the block
  var events: [Tendermint_Abci_Event] = []

  /// the result of executing each transaction including the events
  /// the particular transction emitted. This should match the order
  /// of the transactions delivered in the block itself
  var txResults: [Tendermint_Abci_ExecTxResult] = []

  /// a list of updates to the validator set. These will reflect the validator set at current height + 2.
  var validatorUpdates: [Tendermint_Abci_ValidatorUpdate] = []

  /// updates to the consensus params, if any.
  var consensusParamUpdates: Tendermint_Types_ConsensusParams {
    get {return _consensusParamUpdates ?? Tendermint_Types_ConsensusParams()}
    set {_consensusParamUpdates = newValue}
  }
  /// Returns true if `consensusParamUpdates` has been explicitly set.
  var hasConsensusParamUpdates: Bool {return self._consensusParamUpdates != nil}
  /// Clears the value of `consensusParamUpdates`. Subsequent reads from it will return its default value.
  mutating func clearConsensusParamUpdates() {self._consensusParamUpdates = nil}

  /// app_hash is the hash of the applications' state which is used to confirm that execution of the transactions was
  /// deterministic. It is up to the application to decide which algorithm to use.
  var appHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _consensusParamUpdates: Tendermint_Types_ConsensusParams? = nil
}

struct Tendermint_Abci_CommitInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var round: Int32 = 0

  var votes: [Tendermint_Abci_VoteInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ExtendedCommitInfo is similar to CommitInfo except that it is only used in
/// the PrepareProposal request such that CometBFT can provide vote extensions
/// to the application.
struct Tendermint_Abci_ExtendedCommitInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The round at which the block proposer decided in the previous height.
  var round: Int32 = 0

  /// List of validators' addresses in the last validator set with their voting
  /// information, including vote extensions.
  var votes: [Tendermint_Abci_ExtendedVoteInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Event allows application developers to attach additional information to
/// ResponseFinalizeBlock and ResponseCheckTx.
/// Later, transactions may be queried using these events.
struct Tendermint_Abci_Event: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var attributes: [Tendermint_Abci_EventAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventAttribute is a single key-value pair, associated with an event.
struct Tendermint_Abci_EventAttribute: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  /// nondeterministic
  var index: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ExecTxResult contains results of executing one individual transaction.
///
/// * Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted
struct Tendermint_Abci_ExecTxResult: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var data: Data = Data()

  /// nondeterministic
  var log: String = String()

  /// nondeterministic
  var info: String = String()

  var gasWanted: Int64 = 0

  var gasUsed: Int64 = 0

  /// nondeterministic
  var events: [Tendermint_Abci_Event] = []

  var codespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TxResult contains results of executing the transaction.
///
/// One usage is indexing transaction results.
struct Tendermint_Abci_TxResult: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: Int64 = 0

  var index: UInt32 = 0

  var tx: Data = Data()

  var result: Tendermint_Abci_ExecTxResult {
    get {return _result ?? Tendermint_Abci_ExecTxResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Tendermint_Abci_ExecTxResult? = nil
}

struct Tendermint_Abci_Validator: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The first 20 bytes of SHA256(public key)
  var address: Data = Data()

  /// PubKey pub_key = 2 [(gogoproto.nullable)=false];
  var power: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ValidatorUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pubKey: Tendermint_Crypto_PublicKey {
    get {return _pubKey ?? Tendermint_Crypto_PublicKey()}
    set {_pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  var hasPubKey: Bool {return self._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  mutating func clearPubKey() {self._pubKey = nil}

  var power: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pubKey: Tendermint_Crypto_PublicKey? = nil
}

struct Tendermint_Abci_VoteInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validator: Tendermint_Abci_Validator {
    get {return _validator ?? Tendermint_Abci_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  mutating func clearValidator() {self._validator = nil}

  var blockIDFlag: Tendermint_Types_BlockIDFlag = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _validator: Tendermint_Abci_Validator? = nil
}

struct Tendermint_Abci_ExtendedVoteInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The validator that sent the vote.
  var validator: Tendermint_Abci_Validator {
    get {return _validator ?? Tendermint_Abci_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  mutating func clearValidator() {self._validator = nil}

  /// Non-deterministic extension provided by the sending validator's application.
  var voteExtension: Data = Data()

  /// Vote extension signature created by CometBFT
  var extensionSignature: Data = Data()

  /// block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all
  var blockIDFlag: Tendermint_Types_BlockIDFlag = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _validator: Tendermint_Abci_Validator? = nil
}

struct Tendermint_Abci_Misbehavior: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Tendermint_Abci_MisbehaviorType = .unknown

  /// The offending validator
  var validator: Tendermint_Abci_Validator {
    get {return _validator ?? Tendermint_Abci_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  mutating func clearValidator() {self._validator = nil}

  /// The height when the offense occurred
  var height: Int64 = 0

  /// The corresponding time where the offense occurred
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// Total voting power of the validator set in case the ABCI application does
  /// not store historical validators.
  /// https://github.com/tendermint/tendermint/issues/4581
  var totalVotingPower: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _validator: Tendermint_Abci_Validator? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Tendermint_Abci_Snapshot: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The height at which the snapshot was taken
  var height: UInt64 = 0

  /// The application-specific snapshot format
  var format: UInt32 = 0

  /// Number of chunks in the snapshot
  var chunks: UInt32 = 0

  /// Arbitrary snapshot hash, equal only if identical
  var hash: Data = Data()

  /// Arbitrary application metadata
  var metadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tendermint.abci"

extension Tendermint_Abci_CheckTxType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NEW"),
    1: .same(proto: "RECHECK"),
  ]
}

extension Tendermint_Abci_MisbehaviorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DUPLICATE_VOTE"),
    2: .same(proto: "LIGHT_CLIENT_ATTACK"),
  ]
}

extension Tendermint_Abci_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "echo"),
    2: .same(proto: "flush"),
    3: .same(proto: "info"),
    5: .standard(proto: "init_chain"),
    6: .same(proto: "query"),
    8: .standard(proto: "check_tx"),
    11: .same(proto: "commit"),
    12: .standard(proto: "list_snapshots"),
    13: .standard(proto: "offer_snapshot"),
    14: .standard(proto: "load_snapshot_chunk"),
    15: .standard(proto: "apply_snapshot_chunk"),
    16: .standard(proto: "prepare_proposal"),
    17: .standard(proto: "process_proposal"),
    18: .standard(proto: "extend_vote"),
    19: .standard(proto: "verify_vote_extension"),
    20: .standard(proto: "finalize_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tendermint_Abci_RequestEcho?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .echo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .echo(v)
        }
      }()
      case 2: try {
        var v: Tendermint_Abci_RequestFlush?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .flush(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .flush(v)
        }
      }()
      case 3: try {
        var v: Tendermint_Abci_RequestInfo?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .info(v)
        }
      }()
      case 5: try {
        var v: Tendermint_Abci_RequestInitChain?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .initChain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .initChain(v)
        }
      }()
      case 6: try {
        var v: Tendermint_Abci_RequestQuery?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .query(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .query(v)
        }
      }()
      case 8: try {
        var v: Tendermint_Abci_RequestCheckTx?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .checkTx(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .checkTx(v)
        }
      }()
      case 11: try {
        var v: Tendermint_Abci_RequestCommit?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .commit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .commit(v)
        }
      }()
      case 12: try {
        var v: Tendermint_Abci_RequestListSnapshots?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .listSnapshots(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .listSnapshots(v)
        }
      }()
      case 13: try {
        var v: Tendermint_Abci_RequestOfferSnapshot?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .offerSnapshot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .offerSnapshot(v)
        }
      }()
      case 14: try {
        var v: Tendermint_Abci_RequestLoadSnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .loadSnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .loadSnapshotChunk(v)
        }
      }()
      case 15: try {
        var v: Tendermint_Abci_RequestApplySnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .applySnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .applySnapshotChunk(v)
        }
      }()
      case 16: try {
        var v: Tendermint_Abci_RequestPrepareProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .prepareProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .prepareProposal(v)
        }
      }()
      case 17: try {
        var v: Tendermint_Abci_RequestProcessProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .processProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .processProposal(v)
        }
      }()
      case 18: try {
        var v: Tendermint_Abci_RequestExtendVote?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .extendVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .extendVote(v)
        }
      }()
      case 19: try {
        var v: Tendermint_Abci_RequestVerifyVoteExtension?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .verifyVoteExtension(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .verifyVoteExtension(v)
        }
      }()
      case 20: try {
        var v: Tendermint_Abci_RequestFinalizeBlock?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .finalizeBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .finalizeBlock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .echo?: try {
      guard case .echo(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .flush?: try {
      guard case .flush(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .info?: try {
      guard case .info(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .initChain?: try {
      guard case .initChain(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .query?: try {
      guard case .query(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .checkTx?: try {
      guard case .checkTx(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .commit?: try {
      guard case .commit(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .listSnapshots?: try {
      guard case .listSnapshots(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .offerSnapshot?: try {
      guard case .offerSnapshot(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .loadSnapshotChunk?: try {
      guard case .loadSnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .applySnapshotChunk?: try {
      guard case .applySnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .prepareProposal?: try {
      guard case .prepareProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .processProposal?: try {
      guard case .processProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .extendVote?: try {
      guard case .extendVote(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .verifyVoteExtension?: try {
      guard case .verifyVoteExtension(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .finalizeBlock?: try {
      guard case .finalizeBlock(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Request, rhs: Tendermint_Abci_Request) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestEcho: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestEcho"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestEcho, rhs: Tendermint_Abci_RequestEcho) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestFlush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestFlush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestFlush, rhs: Tendermint_Abci_RequestFlush) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "block_version"),
    3: .standard(proto: "p2p_version"),
    4: .standard(proto: "abci_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockVersion) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.p2PVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.abciVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.blockVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockVersion, fieldNumber: 2)
    }
    if self.p2PVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.p2PVersion, fieldNumber: 3)
    }
    if !self.abciVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.abciVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestInfo, rhs: Tendermint_Abci_RequestInfo) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.blockVersion != rhs.blockVersion {return false}
    if lhs.p2PVersion != rhs.p2PVersion {return false}
    if lhs.abciVersion != rhs.abciVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestInitChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestInitChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .standard(proto: "chain_id"),
    3: .standard(proto: "consensus_params"),
    4: .same(proto: "validators"),
    5: .standard(proto: "app_state_bytes"),
    6: .standard(proto: "initial_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consensusParams) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.appStateBytes) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.initialHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 2)
    }
    try { if let v = self._consensusParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 4)
    }
    if !self.appStateBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.appStateBytes, fieldNumber: 5)
    }
    if self.initialHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.initialHeight, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestInitChain, rhs: Tendermint_Abci_RequestInitChain) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs._consensusParams != rhs._consensusParams {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.appStateBytes != rhs.appStateBytes {return false}
    if lhs.initialHeight != rhs.initialHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "path"),
    3: .same(proto: "height"),
    4: .same(proto: "prove"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.prove) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    if self.prove != false {
      try visitor.visitSingularBoolField(value: self.prove, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestQuery, rhs: Tendermint_Abci_RequestQuery) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.path != rhs.path {return false}
    if lhs.height != rhs.height {return false}
    if lhs.prove != rhs.prove {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestCheckTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestCheckTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 1)
    }
    if self.type != .new {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestCheckTx, rhs: Tendermint_Abci_RequestCheckTx) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestCommit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestCommit, rhs: Tendermint_Abci_RequestCommit) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestListSnapshots: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestListSnapshots"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestListSnapshots, rhs: Tendermint_Abci_RequestListSnapshots) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestOfferSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestOfferSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
    2: .standard(proto: "app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.appHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._snapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.appHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.appHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestOfferSnapshot, rhs: Tendermint_Abci_RequestOfferSnapshot) -> Bool {
    if lhs._snapshot != rhs._snapshot {return false}
    if lhs.appHash != rhs.appHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestLoadSnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestLoadSnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "format"),
    3: .same(proto: "chunk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.format) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.chunk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.format != 0 {
      try visitor.visitSingularUInt32Field(value: self.format, fieldNumber: 2)
    }
    if self.chunk != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestLoadSnapshotChunk, rhs: Tendermint_Abci_RequestLoadSnapshotChunk) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.format != rhs.format {return false}
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestApplySnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestApplySnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "chunk"),
    3: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.chunk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 2)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestApplySnapshotChunk, rhs: Tendermint_Abci_RequestApplySnapshotChunk) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.chunk != rhs.chunk {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestPrepareProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestPrepareProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_tx_bytes"),
    2: .same(proto: "txs"),
    3: .standard(proto: "local_last_commit"),
    4: .same(proto: "misbehavior"),
    5: .same(proto: "height"),
    6: .same(proto: "time"),
    7: .standard(proto: "next_validators_hash"),
    8: .standard(proto: "proposer_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxTxBytes) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._localLastCommit) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.misbehavior) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxTxBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxTxBytes, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 2)
    }
    try { if let v = self._localLastCommit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.misbehavior.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.misbehavior, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nextValidatorsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorsHash, fieldNumber: 7)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestPrepareProposal, rhs: Tendermint_Abci_RequestPrepareProposal) -> Bool {
    if lhs.maxTxBytes != rhs.maxTxBytes {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs._localLastCommit != rhs._localLastCommit {return false}
    if lhs.misbehavior != rhs.misbehavior {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.nextValidatorsHash != rhs.nextValidatorsHash {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestProcessProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestProcessProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
    2: .standard(proto: "proposed_last_commit"),
    3: .same(proto: "misbehavior"),
    4: .same(proto: "hash"),
    5: .same(proto: "height"),
    6: .same(proto: "time"),
    7: .standard(proto: "next_validators_hash"),
    8: .standard(proto: "proposer_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._proposedLastCommit) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.misbehavior) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 1)
    }
    try { if let v = self._proposedLastCommit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.misbehavior.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.misbehavior, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nextValidatorsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorsHash, fieldNumber: 7)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestProcessProposal, rhs: Tendermint_Abci_RequestProcessProposal) -> Bool {
    if lhs.txs != rhs.txs {return false}
    if lhs._proposedLastCommit != rhs._proposedLastCommit {return false}
    if lhs.misbehavior != rhs.misbehavior {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.nextValidatorsHash != rhs.nextValidatorsHash {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestExtendVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestExtendVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .same(proto: "time"),
    4: .same(proto: "txs"),
    5: .standard(proto: "proposed_last_commit"),
    6: .same(proto: "misbehavior"),
    7: .standard(proto: "next_validators_hash"),
    8: .standard(proto: "proposer_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._proposedLastCommit) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.misbehavior) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 4)
    }
    try { if let v = self._proposedLastCommit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.misbehavior.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.misbehavior, fieldNumber: 6)
    }
    if !self.nextValidatorsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorsHash, fieldNumber: 7)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestExtendVote, rhs: Tendermint_Abci_RequestExtendVote) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs._proposedLastCommit != rhs._proposedLastCommit {return false}
    if lhs.misbehavior != rhs.misbehavior {return false}
    if lhs.nextValidatorsHash != rhs.nextValidatorsHash {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestVerifyVoteExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestVerifyVoteExtension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "validator_address"),
    3: .same(proto: "height"),
    4: .standard(proto: "vote_extension"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.voteExtension) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorAddress, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    if !self.voteExtension.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteExtension, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestVerifyVoteExtension, rhs: Tendermint_Abci_RequestVerifyVoteExtension) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.height != rhs.height {return false}
    if lhs.voteExtension != rhs.voteExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestFinalizeBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestFinalizeBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
    2: .standard(proto: "decided_last_commit"),
    3: .same(proto: "misbehavior"),
    4: .same(proto: "hash"),
    5: .same(proto: "height"),
    6: .same(proto: "time"),
    7: .standard(proto: "next_validators_hash"),
    8: .standard(proto: "proposer_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._decidedLastCommit) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.misbehavior) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 1)
    }
    try { if let v = self._decidedLastCommit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.misbehavior.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.misbehavior, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nextValidatorsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorsHash, fieldNumber: 7)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestFinalizeBlock, rhs: Tendermint_Abci_RequestFinalizeBlock) -> Bool {
    if lhs.txs != rhs.txs {return false}
    if lhs._decidedLastCommit != rhs._decidedLastCommit {return false}
    if lhs.misbehavior != rhs.misbehavior {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.nextValidatorsHash != rhs.nextValidatorsHash {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exception"),
    2: .same(proto: "echo"),
    3: .same(proto: "flush"),
    4: .same(proto: "info"),
    6: .standard(proto: "init_chain"),
    7: .same(proto: "query"),
    9: .standard(proto: "check_tx"),
    12: .same(proto: "commit"),
    13: .standard(proto: "list_snapshots"),
    14: .standard(proto: "offer_snapshot"),
    15: .standard(proto: "load_snapshot_chunk"),
    16: .standard(proto: "apply_snapshot_chunk"),
    17: .standard(proto: "prepare_proposal"),
    18: .standard(proto: "process_proposal"),
    19: .standard(proto: "extend_vote"),
    20: .standard(proto: "verify_vote_extension"),
    21: .standard(proto: "finalize_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tendermint_Abci_ResponseException?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .exception(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .exception(v)
        }
      }()
      case 2: try {
        var v: Tendermint_Abci_ResponseEcho?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .echo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .echo(v)
        }
      }()
      case 3: try {
        var v: Tendermint_Abci_ResponseFlush?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .flush(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .flush(v)
        }
      }()
      case 4: try {
        var v: Tendermint_Abci_ResponseInfo?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .info(v)
        }
      }()
      case 6: try {
        var v: Tendermint_Abci_ResponseInitChain?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .initChain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .initChain(v)
        }
      }()
      case 7: try {
        var v: Tendermint_Abci_ResponseQuery?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .query(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .query(v)
        }
      }()
      case 9: try {
        var v: Tendermint_Abci_ResponseCheckTx?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .checkTx(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .checkTx(v)
        }
      }()
      case 12: try {
        var v: Tendermint_Abci_ResponseCommit?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .commit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .commit(v)
        }
      }()
      case 13: try {
        var v: Tendermint_Abci_ResponseListSnapshots?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .listSnapshots(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .listSnapshots(v)
        }
      }()
      case 14: try {
        var v: Tendermint_Abci_ResponseOfferSnapshot?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .offerSnapshot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .offerSnapshot(v)
        }
      }()
      case 15: try {
        var v: Tendermint_Abci_ResponseLoadSnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .loadSnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .loadSnapshotChunk(v)
        }
      }()
      case 16: try {
        var v: Tendermint_Abci_ResponseApplySnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .applySnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .applySnapshotChunk(v)
        }
      }()
      case 17: try {
        var v: Tendermint_Abci_ResponsePrepareProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .prepareProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .prepareProposal(v)
        }
      }()
      case 18: try {
        var v: Tendermint_Abci_ResponseProcessProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .processProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .processProposal(v)
        }
      }()
      case 19: try {
        var v: Tendermint_Abci_ResponseExtendVote?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .extendVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .extendVote(v)
        }
      }()
      case 20: try {
        var v: Tendermint_Abci_ResponseVerifyVoteExtension?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .verifyVoteExtension(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .verifyVoteExtension(v)
        }
      }()
      case 21: try {
        var v: Tendermint_Abci_ResponseFinalizeBlock?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .finalizeBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .finalizeBlock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .exception?: try {
      guard case .exception(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .echo?: try {
      guard case .echo(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .flush?: try {
      guard case .flush(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .info?: try {
      guard case .info(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .initChain?: try {
      guard case .initChain(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .query?: try {
      guard case .query(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .checkTx?: try {
      guard case .checkTx(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .commit?: try {
      guard case .commit(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .listSnapshots?: try {
      guard case .listSnapshots(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .offerSnapshot?: try {
      guard case .offerSnapshot(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .loadSnapshotChunk?: try {
      guard case .loadSnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .applySnapshotChunk?: try {
      guard case .applySnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .prepareProposal?: try {
      guard case .prepareProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .processProposal?: try {
      guard case .processProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .extendVote?: try {
      guard case .extendVote(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .verifyVoteExtension?: try {
      guard case .verifyVoteExtension(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .finalizeBlock?: try {
      guard case .finalizeBlock(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Response, rhs: Tendermint_Abci_Response) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseException: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseException"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseException, rhs: Tendermint_Abci_ResponseException) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseEcho: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseEcho"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseEcho, rhs: Tendermint_Abci_ResponseEcho) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseFlush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseFlush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseFlush, rhs: Tendermint_Abci_ResponseFlush) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "version"),
    3: .standard(proto: "app_version"),
    4: .standard(proto: "last_block_height"),
    5: .standard(proto: "last_block_app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appVersion) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastBlockHeight) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.lastBlockAppHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.appVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.appVersion, fieldNumber: 3)
    }
    if self.lastBlockHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.lastBlockHeight, fieldNumber: 4)
    }
    if !self.lastBlockAppHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastBlockAppHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseInfo, rhs: Tendermint_Abci_ResponseInfo) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.version != rhs.version {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.lastBlockHeight != rhs.lastBlockHeight {return false}
    if lhs.lastBlockAppHash != rhs.lastBlockAppHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseInitChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseInitChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consensus_params"),
    2: .same(proto: "validators"),
    3: .standard(proto: "app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._consensusParams) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.appHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consensusParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    if !self.appHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.appHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseInitChain, rhs: Tendermint_Abci_ResponseInitChain) -> Bool {
    if lhs._consensusParams != rhs._consensusParams {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.appHash != rhs.appHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .same(proto: "index"),
    6: .same(proto: "key"),
    7: .same(proto: "value"),
    8: .standard(proto: "proof_ops"),
    9: .same(proto: "height"),
    10: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._proofOps) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 5)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 6)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 7)
    }
    try { if let v = self._proofOps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 9)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseQuery, rhs: Tendermint_Abci_ResponseQuery) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.index != rhs.index {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._proofOps != rhs._proofOps {return false}
    if lhs.height != rhs.height {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseCheckTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseCheckTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "data"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .same(proto: "gas_wanted"),
    6: .same(proto: "gas_used"),
    7: .same(proto: "events"),
    8: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.gasWanted) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.gasUsed) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.gasWanted != 0 {
      try visitor.visitSingularInt64Field(value: self.gasWanted, fieldNumber: 5)
    }
    if self.gasUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.gasUsed, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 7)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseCheckTx, rhs: Tendermint_Abci_ResponseCheckTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.data != rhs.data {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.gasWanted != rhs.gasWanted {return false}
    if lhs.gasUsed != rhs.gasUsed {return false}
    if lhs.events != rhs.events {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseCommit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "retain_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.retainHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retainHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.retainHeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseCommit, rhs: Tendermint_Abci_ResponseCommit) -> Bool {
    if lhs.retainHeight != rhs.retainHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseListSnapshots: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseListSnapshots"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshots"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.snapshots) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.snapshots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseListSnapshots, rhs: Tendermint_Abci_ResponseListSnapshots) -> Bool {
    if lhs.snapshots != rhs.snapshots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseOfferSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseOfferSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseOfferSnapshot, rhs: Tendermint_Abci_ResponseOfferSnapshot) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseOfferSnapshot.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "ABORT"),
    3: .same(proto: "REJECT"),
    4: .same(proto: "REJECT_FORMAT"),
    5: .same(proto: "REJECT_SENDER"),
  ]
}

extension Tendermint_Abci_ResponseLoadSnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseLoadSnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.chunk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseLoadSnapshotChunk, rhs: Tendermint_Abci_ResponseLoadSnapshotChunk) -> Bool {
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseApplySnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseApplySnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "refetch_chunks"),
    3: .standard(proto: "reject_senders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.refetchChunks) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.rejectSenders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.refetchChunks.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.refetchChunks, fieldNumber: 2)
    }
    if !self.rejectSenders.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rejectSenders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseApplySnapshotChunk, rhs: Tendermint_Abci_ResponseApplySnapshotChunk) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.refetchChunks != rhs.refetchChunks {return false}
    if lhs.rejectSenders != rhs.rejectSenders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseApplySnapshotChunk.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "ABORT"),
    3: .same(proto: "RETRY"),
    4: .same(proto: "RETRY_SNAPSHOT"),
    5: .same(proto: "REJECT_SNAPSHOT"),
  ]
}

extension Tendermint_Abci_ResponsePrepareProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponsePrepareProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponsePrepareProposal, rhs: Tendermint_Abci_ResponsePrepareProposal) -> Bool {
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseProcessProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseProcessProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseProcessProposal, rhs: Tendermint_Abci_ResponseProcessProposal) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseProcessProposal.ProposalStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "REJECT"),
  ]
}

extension Tendermint_Abci_ResponseExtendVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseExtendVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_extension"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.voteExtension) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voteExtension.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteExtension, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseExtendVote, rhs: Tendermint_Abci_ResponseExtendVote) -> Bool {
    if lhs.voteExtension != rhs.voteExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseVerifyVoteExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseVerifyVoteExtension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseVerifyVoteExtension, rhs: Tendermint_Abci_ResponseVerifyVoteExtension) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "REJECT"),
  ]
}

extension Tendermint_Abci_ResponseFinalizeBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseFinalizeBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "tx_results"),
    3: .standard(proto: "validator_updates"),
    4: .standard(proto: "consensus_param_updates"),
    5: .standard(proto: "app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.txResults) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.validatorUpdates) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._consensusParamUpdates) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.appHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if !self.txResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txResults, fieldNumber: 2)
    }
    if !self.validatorUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validatorUpdates, fieldNumber: 3)
    }
    try { if let v = self._consensusParamUpdates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.appHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.appHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseFinalizeBlock, rhs: Tendermint_Abci_ResponseFinalizeBlock) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.txResults != rhs.txResults {return false}
    if lhs.validatorUpdates != rhs.validatorUpdates {return false}
    if lhs._consensusParamUpdates != rhs._consensusParamUpdates {return false}
    if lhs.appHash != rhs.appHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_CommitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_CommitInfo, rhs: Tendermint_Abci_CommitInfo) -> Bool {
    if lhs.round != rhs.round {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ExtendedCommitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtendedCommitInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ExtendedCommitInfo, rhs: Tendermint_Abci_ExtendedCommitInfo) -> Bool {
    if lhs.round != rhs.round {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Event, rhs: Tendermint_Abci_Event) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_EventAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.index != false {
      try visitor.visitSingularBoolField(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_EventAttribute, rhs: Tendermint_Abci_EventAttribute) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ExecTxResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecTxResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "data"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .same(proto: "gas_wanted"),
    6: .same(proto: "gas_used"),
    7: .same(proto: "events"),
    8: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.gasWanted) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.gasUsed) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.gasWanted != 0 {
      try visitor.visitSingularInt64Field(value: self.gasWanted, fieldNumber: 5)
    }
    if self.gasUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.gasUsed, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 7)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ExecTxResult, rhs: Tendermint_Abci_ExecTxResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.data != rhs.data {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.gasWanted != rhs.gasWanted {return false}
    if lhs.gasUsed != rhs.gasUsed {return false}
    if lhs.events != rhs.events {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_TxResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "index"),
    3: .same(proto: "tx"),
    4: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 3)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_TxResult, rhs: Tendermint_Abci_TxResult) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.index != rhs.index {return false}
    if lhs.tx != rhs.tx {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Validator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    3: .same(proto: "power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Validator, rhs: Tendermint_Abci_Validator) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ValidatorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pubKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ValidatorUpdate, rhs: Tendermint_Abci_ValidatorUpdate) -> Bool {
    if lhs._pubKey != rhs._pubKey {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_VoteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoteInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    3: .standard(proto: "block_id_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.blockIDFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.blockIDFlag != .unknown {
      try visitor.visitSingularEnumField(value: self.blockIDFlag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_VoteInfo, rhs: Tendermint_Abci_VoteInfo) -> Bool {
    if lhs._validator != rhs._validator {return false}
    if lhs.blockIDFlag != rhs.blockIDFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ExtendedVoteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtendedVoteInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    3: .standard(proto: "vote_extension"),
    4: .standard(proto: "extension_signature"),
    5: .standard(proto: "block_id_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.voteExtension) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.extensionSignature) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.blockIDFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.voteExtension.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteExtension, fieldNumber: 3)
    }
    if !self.extensionSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.extensionSignature, fieldNumber: 4)
    }
    if self.blockIDFlag != .unknown {
      try visitor.visitSingularEnumField(value: self.blockIDFlag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ExtendedVoteInfo, rhs: Tendermint_Abci_ExtendedVoteInfo) -> Bool {
    if lhs._validator != rhs._validator {return false}
    if lhs.voteExtension != rhs.voteExtension {return false}
    if lhs.extensionSignature != rhs.extensionSignature {return false}
    if lhs.blockIDFlag != rhs.blockIDFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Misbehavior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Misbehavior"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "validator"),
    3: .same(proto: "height"),
    4: .same(proto: "time"),
    5: .standard(proto: "total_voting_power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalVotingPower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.totalVotingPower != 0 {
      try visitor.visitSingularInt64Field(value: self.totalVotingPower, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Misbehavior, rhs: Tendermint_Abci_Misbehavior) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._validator != rhs._validator {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.totalVotingPower != rhs.totalVotingPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Snapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Snapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "format"),
    3: .same(proto: "chunks"),
    4: .same(proto: "hash"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.format) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.chunks) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.format != 0 {
      try visitor.visitSingularUInt32Field(value: self.format, fieldNumber: 2)
    }
    if self.chunks != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunks, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Snapshot, rhs: Tendermint_Abci_Snapshot) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.format != rhs.format {return false}
    if lhs.chunks != rhs.chunks {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
