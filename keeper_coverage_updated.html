
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>keeper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/burnt-labs/xion/x/xion/keeper/genesis.go (90.9%)</option>
				
				<option value="file1">github.com/burnt-labs/xion/x/xion/keeper/grpc_query.go (47.7%)</option>
				
				<option value="file2">github.com/burnt-labs/xion/x/xion/keeper/keeper.go (93.8%)</option>
				
				<option value="file3">github.com/burnt-labs/xion/x/xion/keeper/mint.go (0.0%)</option>
				
				<option value="file4">github.com/burnt-labs/xion/x/xion/keeper/msg_server.go (39.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package keeper

import (
        "encoding/binary"

        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/burnt-labs/xion/x/xion/types"
)

// InitGenesis initializes the bank module's state from a given genesis state.
func (k Keeper) InitGenesis(ctx sdk.Context, genState *types.GenesisState) <span class="cov8" title="1">{
        k.OverwritePlatformPercentage(ctx, genState.PlatformPercentage)
        err := k.OverwritePlatformMinimum(ctx, genState.PlatformMinimums)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// ExportGenesis returns the bank module's genesis state.
func (k Keeper) ExportGenesis(ctx sdk.Context) *types.GenesisState <span class="cov8" title="1">{
        bz := ctx.KVStore(k.storeKey).Get(types.PlatformPercentageKey)
        platformPercentage := binary.BigEndian.Uint32(bz)

        platformMinimums, err := k.GetPlatformMinimums(ctx)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">rv := types.NewGenesisState(platformPercentage, platformMinimums)
        return rv</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package keeper

import (
        "bytes"
        "context"
        "encoding/binary"
        "encoding/json"
        "fmt"
        "io"
        "net/url"

        "github.com/go-webauthn/webauthn/protocol"
        "github.com/go-webauthn/webauthn/protocol/webauthncbor"
        "github.com/go-webauthn/webauthn/webauthn"

        errorsmod "cosmossdk.io/errors"

        sdktypes "github.com/cosmos/cosmos-sdk/types"

        "github.com/burnt-labs/xion/x/xion/types"
)

var _ types.QueryServer = Keeper{}

func (k Keeper) WebAuthNVerifyRegister(ctx context.Context, request *types.QueryWebAuthNVerifyRegisterRequest) (*types.QueryWebAuthNVerifyRegisterResponse, error) <span class="cov0" title="0">{
        rp, err := url.Parse(request.Rp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateCredentialCreation(bytes.NewReader(request.Data)); err != nil </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(types.ErrNoValidWebAuth, err.Error())
        }</span>

        <span class="cov0" title="0">data, err := protocol.ParseCredentialCreationResponseBody(bytes.NewReader(request.Data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(types.ErrNoValidWebAuth, err.Error())
        }</span>

        <span class="cov0" title="0">sdkCtx := sdktypes.UnwrapSDKContext(ctx) // NOTE: verify this is the same for X nodes
        credential, err := types.VerifyRegistration(sdkCtx, rp, request.Addr, request.Challenge, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(types.ErrNoValidWebAuth, err.Error())
        }</span>

        <span class="cov0" title="0">credentialBz, err := json.Marshal(&amp;credential)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryWebAuthNVerifyRegisterResponse{Credential: credentialBz}, nil</span>
}

func (k Keeper) WebAuthNVerifyAuthenticate(_ context.Context, request *types.QueryWebAuthNVerifyAuthenticateRequest) (*types.QueryWebAuthNVerifyAuthenticateResponse, error) <span class="cov0" title="0">{
        rp, err := url.Parse(request.Rp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateCredentialRequest(bytes.NewReader(request.Data)); err != nil </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(types.ErrNoValidWebAuth, err.Error())
        }</span>

        <span class="cov0" title="0">data, err := protocol.ParseCredentialRequestResponseBody(bytes.NewReader(request.Data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(types.ErrNoValidWebAuth, err.Error())
        }</span>

        <span class="cov0" title="0">var credential webauthn.Credential
        err = json.Unmarshal(request.Credential, &amp;credential)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = types.VerifyAuthentication(rp, request.Addr, request.Challenge, &amp;credential, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryWebAuthNVerifyAuthenticateResponse{}, nil</span>
}

// PlatformPercentage implements types.QueryServer.
func (k Keeper) PlatformPercentage(ctx context.Context, _ *types.QueryPlatformPercentageRequest) (*types.QueryPlatformPercentageResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdktypes.UnwrapSDKContext(ctx)
        percentage := k.GetPlatformPercentage(sdkCtx).Uint64()
        return &amp;types.QueryPlatformPercentageResponse{PlatformPercentage: percentage}, nil
}</span>

// PlatformMinimum implements types.QueryServer.
func (k Keeper) PlatformMinimum(ctx context.Context, _ *types.QueryPlatformMinimumRequest) (*types.QueryPlatformMinimumResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdktypes.UnwrapSDKContext(ctx)
        coins, err := k.GetPlatformMinimums(sdkCtx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.QueryPlatformMinimumResponse{Minimums: coins}, nil</span>
}

func validateCredentialCreation(body io.Reader) error <span class="cov8" title="1">{
        var ccr protocol.CredentialCreationResponse

        if err := json.NewDecoder(body).Decode(&amp;ccr); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">p := &amp;protocol.ParsedAttestationResponse{}

        if err := json.Unmarshal(ccr.AttestationResponse.ClientDataJSON, &amp;p.CollectedClientData); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := webauthncbor.Unmarshal(ccr.AttestationResponse.AttestationObject, &amp;p.AttestationObject); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return validateAttestation(p.AttestationObject.RawAuthData)</span>
}

func validateCredentialRequest(body io.Reader) error <span class="cov8" title="1">{
        var car protocol.CredentialAssertionResponse
        if err := json.NewDecoder(body).Decode(&amp;car); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return validateAttestation(car.AssertionResponse.AuthenticatorData)</span>
}

func validateAttestation(rawAuthData []byte) error <span class="cov8" title="1">{
        var a protocol.AuthenticatorData

        minAuthDataLength := 37
        if minAuthDataLength &gt; len(rawAuthData) </span><span class="cov8" title="1">{
                return fmt.Errorf("expected data greater than %d bytes. Got %d bytes", minAuthDataLength, len(rawAuthData))
        }</span>

        <span class="cov8" title="1">a.RPIDHash = rawAuthData[:32]
        a.Flags = protocol.AuthenticatorFlags(rawAuthData[32])
        a.Counter = binary.BigEndian.Uint32(rawAuthData[33:37])

        remaining := len(rawAuthData) - minAuthDataLength

        if a.Flags.HasExtensions() </span><span class="cov8" title="1">{
                if remaining != 0 &amp;&amp; len(rawAuthData)-remaining &gt; len(rawAuthData) </span><span class="cov0" title="0">{
                        return fmt.Errorf("raw auth data seems to be malformed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package keeper

import (
        "encoding/json"

        wasmtypes "github.com/CosmWasm/wasmd/x/wasm/types"

        "cosmossdk.io/log"
        "cosmossdk.io/math"
        storetypes "cosmossdk.io/store/types"

        "github.com/cosmos/cosmos-sdk/codec"
        sdktypes "github.com/cosmos/cosmos-sdk/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"

        "github.com/burnt-labs/xion/x/xion/types"
)

type Keeper struct {
        cdc                codec.BinaryCodec
        storeKey           storetypes.StoreKey
        paramSpace         paramtypes.Subspace
        bankKeeper         types.BankKeeper
        accountKeeper      types.AccountKeeper
        ContractOpsKeeper  wasmtypes.ContractOpsKeeper
        ContractViewKeeper wasmtypes.ViewKeeper
        AAKeeper           types.AbstractAccountKeeper

        // the address capable of executing a MsgSetPlatformPercentage message.
        // Typically, this should be the x/gov module account
        authority string
}

func NewKeeper(cdc codec.BinaryCodec,
        key storetypes.StoreKey,
        paramSpace paramtypes.Subspace,
        bankKeeper types.BankKeeper,
        accountKeeper types.AccountKeeper,
        wasmOpsKeeper wasmtypes.ContractOpsKeeper,
        wasmViewKeeper wasmtypes.ViewKeeper,
        aaKeeper types.AbstractAccountKeeper,
        authority string,
) Keeper <span class="cov8" title="1">{
        return Keeper{
                storeKey:           key,
                cdc:                cdc,
                paramSpace:         paramSpace,
                bankKeeper:         bankKeeper,
                accountKeeper:      accountKeeper,
                ContractOpsKeeper:  wasmOpsKeeper,
                ContractViewKeeper: wasmViewKeeper,
                AAKeeper:           aaKeeper,
                authority:          authority,
        }
}</span>

// Logger returns a module-specific logger.
func (k Keeper) Logger(ctx sdktypes.Context) log.Logger <span class="cov8" title="1">{
        return ctx.Logger().With("module", "x/"+types.ModuleName)
}</span>

// Platform Percentage
func (k Keeper) GetPlatformPercentage(ctx sdktypes.Context) math.Int <span class="cov8" title="1">{
        bz := ctx.KVStore(k.storeKey).Get(types.PlatformPercentageKey)
        percentage := sdktypes.BigEndianToUint64(bz)
        return math.NewIntFromUint64(percentage)
}</span>

func (k Keeper) OverwritePlatformPercentage(ctx sdktypes.Context, percentage uint32) <span class="cov8" title="1">{
        ctx.KVStore(k.storeKey).Set(types.PlatformPercentageKey, sdktypes.Uint64ToBigEndian(uint64(percentage)))
}</span>

// Platform Minimum
func (k Keeper) GetPlatformMinimums(ctx sdktypes.Context) (coins sdktypes.Coins, err error) <span class="cov8" title="1">{
        bz := ctx.KVStore(k.storeKey).Get(types.PlatformMinimumKey)

        if len(bz) != 0 </span><span class="cov8" title="1">{
                err = json.Unmarshal(bz, &amp;coins)
        }</span>

        <span class="cov8" title="1">return coins, err</span>
}

func (k Keeper) OverwritePlatformMinimum(ctx sdktypes.Context, coins sdktypes.Coins) error <span class="cov8" title="1">{
        bz, err := json.Marshal(coins)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ctx.KVStore(k.storeKey).Set(types.PlatformMinimumKey, bz)
        return nil</span>
}

// Authority

// GetAuthority returns the x/xion module's authority.
func (k Keeper) GetAuthority() string <span class="cov8" title="1">{
        return k.authority
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package keeper

import (
        "time"

        "cosmossdk.io/math"

        "github.com/cosmos/cosmos-sdk/telemetry"
        sdk "github.com/cosmos/cosmos-sdk/types"
        mintkeeper "github.com/cosmos/cosmos-sdk/x/mint/keeper"
        minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"

        "github.com/burnt-labs/xion/x/xion/types"
)

const (
        AttributeKeyCollectedAmount = "collected_amount"
        AttributeKeyMintedAmount    = "minted_amount"
        AttributeKeyBurnedAmount    = "burned_amount"
        AttributeKeyNeededAmount    = "needed_amount"
)

func StakedInflationMintFn(feeCollectorName string, ic minttypes.InflationCalculationFn, bankKeeper types.BankKeeper, accountKeeper types.AccountKeeper, stakingKeeper types.StakingKeeper) func(ctx sdk.Context, k *mintkeeper.Keeper) error <span class="cov0" title="0">{
        return func(ctx sdk.Context, k *mintkeeper.Keeper) error </span><span class="cov0" title="0">{
                defer telemetry.ModuleMeasureSince(minttypes.ModuleName, time.Now(), telemetry.MetricKeyBeginBlocker)

                // fetch stored minter &amp; params
                minter, err := k.Minter.Get(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">params, err := k.Params.Get(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // fetch collected fees
                <span class="cov0" title="0">collectedFeeCoin := bankKeeper.GetBalance(ctx, accountKeeper.GetModuleAccount(ctx, feeCollectorName).GetAddress(), params.MintDenom)

                // recalculate inflation rate
                bondedRatio, err := k.BondedRatio(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">minter.Inflation = ic(ctx, minter, params, bondedRatio)

                bondedTokenSupply, err := stakingKeeper.TotalBondedTokens(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">minter.AnnualProvisions = minter.NextAnnualProvisions(params, bondedTokenSupply)
                if err := k.Minter.Set(ctx, minter); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // mint coins, update supply
                <span class="cov0" title="0">neededCoin := minter.BlockProvision(params)
                mintedCoin := sdk.NewCoin(params.MintDenom, math.ZeroInt())
                burnedCoin := sdk.NewCoin(params.MintDenom, math.ZeroInt())

                if collectedFeeCoin.IsLT(neededCoin) </span><span class="cov0" title="0">{
                        // if the fee collector has not collected enough fees to meet the
                        // staking incentive goals, mint enough to meet.
                        mintedCoin = neededCoin.Sub(collectedFeeCoin)
                        mintedCoins := sdk.NewCoins(mintedCoin)

                        err := k.MintCoins(ctx, mintedCoins)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // send the minted coins to the fee collector account
                        <span class="cov0" title="0">err = k.AddCollectedFees(ctx, mintedCoins)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if mintedCoin.Amount.IsInt64() </span><span class="cov0" title="0">{
                                defer telemetry.ModuleSetGauge(types.ModuleName, float32(mintedCoin.Amount.Int64()), "minted_tokens")
                        }</span>

                } else<span class="cov0" title="0"> {
                        // if the fee collector has collected more fees than are needed to meet the
                        // staking incentive goals, burn the rest.
                        burnedCoin = collectedFeeCoin.Sub(neededCoin)
                        burnedCoins := sdk.NewCoins(burnedCoin)
                        err := bankKeeper.BurnCoins(ctx, feeCollectorName, burnedCoins)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">ctx.EventManager().EmitEvent(
                        sdk.NewEvent(
                                minttypes.EventTypeMint,
                                sdk.NewAttribute(minttypes.AttributeKeyBondedRatio, bondedRatio.String()),
                                sdk.NewAttribute(minttypes.AttributeKeyInflation, minter.Inflation.String()),
                                sdk.NewAttribute(minttypes.AttributeKeyAnnualProvisions, minter.AnnualProvisions.String()),
                                sdk.NewAttribute(AttributeKeyNeededAmount, neededCoin.Amount.String()),
                                sdk.NewAttribute(AttributeKeyMintedAmount, mintedCoin.Amount.String()),
                                sdk.NewAttribute(AttributeKeyCollectedAmount, collectedFeeCoin.Amount.String()),
                                sdk.NewAttribute(AttributeKeyBurnedAmount, burnedCoin.Amount.String()),
                        ),
                )

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package keeper

import (
        "context"
        "fmt"

        "github.com/hashicorp/go-metrics"

        errorsmod "cosmossdk.io/errors"
        "cosmossdk.io/math"

        "github.com/cosmos/cosmos-sdk/telemetry"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
        banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"

        "github.com/burnt-labs/xion/x/xion/types"
)

type msgServer struct {
        Keeper
}

var _ types.MsgServer = msgServer{}

// NewMsgServerImpl returns an implementation of the bank MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: keeper}
}</span>

func (k msgServer) Send(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        if err := k.bankKeeper.IsSendEnabledCoins(ctx, msg.Amount...); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">from, err := sdk.AccAddressFromBech32(msg.FromAddress)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">to, err := sdk.AccAddressFromBech32(msg.ToAddress)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if k.bankKeeper.BlockedAddr(to) </span><span class="cov8" title="1">{
                return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.ToAddress)
        }</span>

        <span class="cov8" title="1">percentage := k.GetPlatformPercentage(ctx)
        minimums, err := k.GetPlatformMinimums(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">throughCoins := msg.Amount
        if !msg.Amount.IsAnyGT(minimums) </span><span class="cov8" title="1">{
                // minimum has not been met. no coin in msg.Amount exceeds a minimum that has been set
                return nil, errorsmod.Wrapf(types.ErrMinimumNotMet, "received %v, needed at least %v", msg.Amount, minimums)
        }</span>

        <span class="cov8" title="1">if !percentage.IsZero() </span><span class="cov8" title="1">{
                platformCoins := msg.Amount.MulInt(percentage).QuoInt(math.NewInt(10000))
                throughCoins = throughCoins.Sub(platformCoins...)

                if err := k.bankKeeper.SendCoinsFromAccountToModule(ctx, from, authtypes.FeeCollectorName, platformCoins); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">err = k.bankKeeper.SendCoins(ctx, from, to, throughCoins)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                for _, a := range throughCoins </span><span class="cov8" title="1">{
                        if a.Amount.IsInt64() </span><span class="cov8" title="1">{
                                telemetry.SetGaugeWithLabels(
                                        []string{"tx", "msg", "send"},
                                        float32(a.Amount.Int64()),
                                        []metrics.Label{telemetry.NewLabel("denom", a.Denom)},
                                )
                        }</span>
                }
        }()

        <span class="cov8" title="1">return &amp;types.MsgSendResponse{}, nil</span>
}

func (k msgServer) MultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // NOTE: totalIn == totalOut should already have been checked
        for _, in := range msg.Inputs </span><span class="cov0" title="0">{
                if err := k.bankKeeper.IsSendEnabledCoins(ctx, in.Coins...); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">percentage := k.GetPlatformPercentage(ctx)
        minimums, err := k.GetPlatformMinimums(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var outputs []banktypes.Output
        totalPlatformCoins := sdk.NewCoins()

        if !msg.Inputs[0].Coins.IsAnyGT(minimums) </span><span class="cov0" title="0">{
                // minimum has not been met. no coin in msg.Amount exceeds a minimum that has been set
                return nil, errorsmod.Wrapf(types.ErrMinimumNotMet, "received %v, needed at least %v", msg.Inputs[0].Coins, minimums)
        }</span>

        <span class="cov0" title="0">for _, out := range msg.Outputs </span><span class="cov0" title="0">{
                accAddr := sdk.MustAccAddressFromBech32(out.Address)

                if k.bankKeeper.BlockedAddr(accAddr) </span><span class="cov0" title="0">{
                        return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", out.Address)
                }</span>

                // if there is a platform fee set, reduce it from each output
                <span class="cov0" title="0">if !percentage.IsZero() </span><span class="cov0" title="0">{
                        platformCoins := out.Coins.MulInt(percentage).QuoInt(math.NewInt(10000))
                        throughCoins, wentNegative := out.Coins.SafeSub(platformCoins...)
                        if wentNegative </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unable to subtract %v from %v", platformCoins, throughCoins)
                        }</span>

                        <span class="cov0" title="0">outputs = append(outputs, banktypes.NewOutput(accAddr, throughCoins))
                        totalPlatformCoins = totalPlatformCoins.Add(platformCoins...)</span>
                } else<span class="cov0" title="0"> {
                        outputs = append(outputs, out)
                }</span>
        }

        // if there is a platform fee set, create the final total output for module account
        <span class="cov0" title="0">if !totalPlatformCoins.IsZero() </span><span class="cov0" title="0">{
                feeCollectorAcc := k.accountKeeper.GetModuleAccount(ctx, authtypes.FeeCollectorName).GetAddress()
                outputs = append(outputs, banktypes.NewOutput(feeCollectorAcc, totalPlatformCoins))
        }</span>

        <span class="cov0" title="0">err = k.bankKeeper.InputOutputCoins(ctx, msg.Inputs[0], outputs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgMultiSendResponse{}, nil</span>
}

func (k msgServer) SetPlatformPercentage(goCtx context.Context, msg *types.MsgSetPlatformPercentage) (*types.MsgSetPlatformPercentageResponse, error) <span class="cov0" title="0">{
        if k.GetAuthority() != msg.Authority </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), msg.Authority)
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)
        k.OverwritePlatformPercentage(ctx, msg.PlatformPercentage)

        return &amp;types.MsgSetPlatformPercentageResponse{}, nil</span>
}

func (k msgServer) SetPlatformMinimum(goCtx context.Context, msg *types.MsgSetPlatformMinimum) (*types.MsgSetPlatformMinimumResponse, error) <span class="cov0" title="0">{
        if k.GetAuthority() != msg.Authority </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), msg.Authority)
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)
        err := k.OverwritePlatformMinimum(ctx, msg.Minimums)

        return &amp;types.MsgSetPlatformMinimumResponse{}, err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
