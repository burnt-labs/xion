package ante

import (
	"testing"

	"github.com/stretchr/testify/require"

	"cosmossdk.io/math"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

func TestCombinedFeeRequirementUnsortedBug(t *testing.T) {
	// Test case from vulnerability report
	coin0High := sdk.NewDecCoin("uxion", math.NewInt(4)) // Min gas price
	coin1High := sdk.NewDecCoin("uxion", math.NewInt(3)) // Global fee
	coin2High := sdk.NewDecCoin("uatom", math.NewInt(8)) // Min gas price
	coin3High := sdk.NewDecCoin("uatom", math.NewInt(7)) // Global fee

	t.Run("vulnerability demonstration - unsorted input coins", func(t *testing.T) {
		// Create UNSORTED coins (this is the bug scenario)
		globalFees := sdk.DecCoins{coin1High, coin3High}   // 3 uxion, 7 uatom (unsorted: uxion comes before uatom)
		minGasPrices := sdk.DecCoins{coin0High, coin2High} // 4 uxion, 8 uatom (unsorted: uxion comes before uatom)

		t.Logf("Global fees (unsorted): %s", globalFees.String())
		t.Logf("Min gas prices (unsorted): %s", minGasPrices.String())

		// The Find function expects sorted coins but these are not sorted
		allFees, err := CombinedFeeRequirement(globalFees, minGasPrices)
		require.NoError(t, err)

		t.Logf("Combined fees result: %s", allFees.String())

		// Expected: Should take maximum of each denom: 4 uxion, 8 uatom
		// Actual bug: Takes 3 uxion, 8 uatom because Find function fails on unsorted coins

		// Verify the bug exists
		uxionAmount := allFees.AmountOf("uxion")
		uatomAmount := allFees.AmountOf("uatom")

		t.Logf("Result uxion amount: %s (expected 4)", uxionAmount.String())
		t.Logf("Result uatom amount: %s (expected 8)", uatomAmount.String())

		// The bug: uxion amount is 3 instead of 4
		if uxionAmount.Equal(math.LegacyNewDec(3)) {
			t.Logf("ðŸš¨ BUG CONFIRMED: uxion amount is 3 instead of expected 4")
			t.Logf("   Root cause: Find function fails on unsorted coins")
		}

		// uatom should be correct (8)
		require.True(t, uatomAmount.Equal(math.LegacyNewDec(8)), "uatom amount should be 8")
	})

	t.Run("correct behavior with sorted input coins", func(t *testing.T) {
		// Same test but with SORTED coins
		globalFees := sdk.DecCoins{coin1High, coin3High}.Sort()   // Properly sorted
		minGasPrices := sdk.DecCoins{coin0High, coin2High}.Sort() // Properly sorted

		t.Logf("Global fees (sorted): %s", globalFees.String())
		t.Logf("Min gas prices (sorted): %s", minGasPrices.String())

		allFees, err := CombinedFeeRequirement(globalFees, minGasPrices)
		require.NoError(t, err)

		t.Logf("Combined fees result: %s", allFees.String())

		// With sorted coins, Find function works correctly
		uxionAmount := allFees.AmountOf("uxion")
		uatomAmount := allFees.AmountOf("uatom")

		t.Logf("Result uxion amount: %s (expected 4)", uxionAmount.String())
		t.Logf("Result uatom amount: %s (expected 8)", uatomAmount.String())

		// Should get the correct maximum values
		require.True(t, uxionAmount.Equal(math.LegacyNewDec(4)), "uxion amount should be 4")
		require.True(t, uatomAmount.Equal(math.LegacyNewDec(8)), "uatom amount should be 8")
	})

	t.Run("demonstrate Find function bug", func(t *testing.T) {
		// Test Find function directly with unsorted coins
		unsortedCoins := sdk.DecCoins{
			sdk.NewDecCoin("uxion", math.NewInt(4)),
			sdk.NewDecCoin("uatom", math.NewInt(8)),
		}

		// Find expects sorted coins (binary search), but these are alphabetically sorted
		// which means uatom should come before uxion, but we have uxion first

		found, coin := Find(unsortedCoins, "uxion")
		t.Logf("Find uxion in unsorted coins: found=%t, coin=%s", found, coin.String())

		found, coin = Find(unsortedCoins, "uatom")
		t.Logf("Find uatom in unsorted coins: found=%t, coin=%s", found, coin.String())

		// Now test with properly sorted coins
		sortedCoins := unsortedCoins.Sort()
		t.Logf("Sorted coins: %s", sortedCoins.String())

		found, coin = Find(sortedCoins, "uxion")
		t.Logf("Find uxion in sorted coins: found=%t, coin=%s", found, coin.String())

		found, coin = Find(sortedCoins, "uatom")
		t.Logf("Find uatom in sorted coins: found=%t, coin=%s", found, coin.String())
	})
}
